sql,plan,request
"--
WITH

result AS (

    SELECT
        count()
    FROM hyperskill_private.users
    WHERE dictGetString(
              'hyperskill.alt_cities_country_dict',
              'name',
              toUInt64(country_by_ip_id)
          ) NOT IN ('Russia', 'Belarus')
        AND hypercoins > 100
        AND sub_premium_dts['created_at_min'] != toDateTime(0)
        AND user_id NOT IN (
            SELECT user_id FROM hyperskill.users_is_biased
        )

)

SELECT *
FROM result;","1. Describe the expected query result: The query will return a count of users from the 'hyperskill_private.users' table who meet certain criteria.

2. Break down the query into logical parts: The query consists of a Common Table Expression (CTE) named 'result' and a final SELECT statement to retrieve the data from the CTE.

3. Description of each part:

- CTE 'result':
  - Perform a SELECT statement to count the number of users.
  - Filter users from the 'hyperskill_private.users' table where the country, derived from 'country_by_ip_id' using the 'dictGetString' function and the 'hyperskill.alt_cities_country_dict' dictionary, is not 'Russia' or 'Belarus'.
  - Ensure that users have more than 100 hypercoins.
  - Check that the 'created_at_min' value in the 'sub_premium_dts' map is not equal to the zero DateTime.
  - Exclude users who are present in the 'hyperskill.users_is_biased' table.

- Final SELECT statement:
  - Retrieve all columns from the CTE 'result', which in this case is just the count of users meeting the above criteria.","Can you provide me with the number of users who are not from Russia or Belarus, have more than 100 hypercoins, are premium subscribers, and are not flagged as biased in our database?"
"--
CREATE OR REPLACE VIEW hyperskill_reports.notifications_log
AS
WITH

user_data AS (

    SELECT
        user_id,
        groupArrayIf(
                map(
                    'email_notification_id',
                        extractURLParameter(page, 'notification_id'),
                    'website_notification_id',
                        JSONExtractString(frontend_context, 'id'),
                    'frontend_dt',
                        toString(frontend_dt),
                    'mobile_notification_id',
                        JSONExtractString(frontend_context, 'notification_id')
                ),
                (page LIKE '%utm_source=notifications_hs%') OR (page_part = 'notification')
        ) AS notifications_clicks,
        groupArrayIf(
            frontend_dt,
            (action = 'click')
                AND (page LIKE '%/learn%')
                AND (target = 'send')
        ) AS submissions_runs
    FROM hyperskill.content
    WHERE date >= toDate(toStartOfInterval(today(), toIntervalDay(35)))
        AND action IN ('view', 'click')
        AND platform IN ('web', 'iOS', 'Android')
    GROUP BY user_id
    HAVING notifications_clicks != []

),

user_activity_log AS (

    SELECT
        user_id,
        toInt64OrZero((arrayJoin(notifications_clicks) AS click_data)['email_notification_id']) AS email_notification_id,
        toInt64OrZero(click_data['website_notification_id']) AS website_notification_id,
        toInt64OrZero(click_data['mobile_notification_id']) AS mobile_notification_id,
        multiIf(
            website_notification_id > 0, website_notification_id,
            email_notification_id > 0, email_notification_id,
            mobile_notification_id > 0, mobile_notification_id,
            0
        ) AS notification_id,
        toDateTime(
            if(
                email_notification_id = notification_id, click_data['frontend_dt'] AS click_dt,
                '1970-01-01 00:00:00'
            )
        ) AS email_click_dt,
        toDateTime(
            if(
                website_notification_id = notification_id, click_dt,
                '1970-01-01 00:00:00'
            )
        ) AS website_click_dt,
        toDateTime(
            if(
                mobile_notification_id = notification_id, click_dt,
                '1970-01-01 00:00:00'
            )
        ) AS app_click_dt,
        arrayJoin(submissions_runs) AS submission_dt
    FROM user_data
    WHERE notification_id != 0

),

notification_templates AS (

    SELECT
        id,
        channel,
        name,
        trigger
    FROM hyperskill_mariadb.notifications_templatenotification
    WHERE enabled = 1
        AND deleted_at IS NULL

),

result AS (

    SELECT
        time,
        toDate(time) AS cohort_day,
        toMonday(time) AS cohort_week,
        toDate(toStartOfInterval(time, toIntervalDay(28))) AS cohort_28d,
        notifications.user_id AS user_id,
        notifications.id AS notification_id,
        multiIf(
            (notification_templates.channel AS ch) = 0, 'web',
            ch = 1, 'email',
            ch = 2, 'mobile',
            ch = 3, 'web_and_mobile',
            'Bug! Please, report in slack #data!'
        ) AS channel,
        notification_templates.name AS notification_type,
        status AS is_opened,
        website_click_dt,
        email_click_dt,
        app_click_dt,
        submission_dt,
        is_sent_email,
        email_first_read_at
    FROM hyperskill_mariadb.notifications_notification AS notifications

    LEFT JOIN user_activity_log ON (user_activity_log.notification_id, user_activity_log.user_id) = (notifications.id, notifications.user_id)

    LEFT JOIN notification_templates ON notification_templates.id = notifications.template_id

    WHERE time >= toDate(toStartOfInterval(today(), toIntervalDay(35)))
        AND user_id NOT IN (
            SELECT user_id
            FROM hyperskill.users_is_biased
        )

)

SELECT *
FROM result","The query is designed to create or replace a view named 'hyperskill_reports.notifications_log'. The expected result of this query is a view that consolidates user interaction with notifications and their subsequent activities on the platform. The view will include details such as the type of notification, whether it was opened, and any submissions made by the user after receiving the notification. The data is filtered to only include interactions from the last 35 days and excludes biased users.

The query is broken down into the following logical parts:

1. user_data: This part aggregates user interactions with notifications and their submission runs. It filters actions to 'view' and 'click', and platforms to 'web', 'iOS', and 'Android'. It groups by user_id and collects arrays of notification clicks and submission run timestamps.

2. user_activity_log: This part processes the aggregated data from user_data to extract individual notification IDs and timestamps for different platforms (email, website, mobile). It also joins the submission run timestamps to the corresponding user and notification.

3. notification_templates: This part selects the notification template details such as id, channel, name, and trigger from the 'notifications_templatenotification' table, filtering out disabled or deleted templates.

4. result: This part combines the user activity log with the notification data and template information. It calculates cohort-related dates and includes user and notification IDs, channel, notification type, and various timestamps related to notification interactions and submission runs. It filters out biased users.

5. Final SELECT: This part selects all columns from the 'result' CTE to form the final view.","Can you provide a report that shows how our users have been interacting with different types of notifications over the past month? Specifically, I'm interested in which notifications they're opening and if they're taking any actions, like submitting something, after receiving them. Please exclude any data from biased users and focus on the most recent 35 days."
"--
WITH

result AS (

    SELECT
        multiIf(
            selected_track_id = 18, 'kotlin_core',
            selected_track_id = 15, 'java_core',
            selected_track_id = 2, 'python_core',
            'other'
        ) AS track,
        registration_date AS cohort,
        countIf(
            action, action = 'completed_step'
                AND date = registration_date + 1
        ) / uniqExact(user_id) AS metric
    FROM hyperskill.content
    WHERE date BETWEEN toDate('2023-09-18') - 14 AND toDate('2023-09-18') + 7
        AND registration_date BETWEEN toDate('2023-09-18') - 14 AND toDate('2023-09-18') + 7
        AND action IN ('view', 'completed_step')
        AND track_id != 0
        AND is_biased = 0
        AND is_guest = 0
        AND is_superuser = 0
    GROUP BY cohort, track
    ORDER BY cohort

)

SELECT *
FROM result;","1. Describe the expected query result: The query will produce a result set that includes the name of the track, the cohort (registration date), and a calculated metric. The metric is the ratio of the number of 'completed_step' actions on the day after registration to the unique count of user IDs.

2. Break down the query into logical parts: The query consists of a Common Table Expression (CTE) named 'result' and a final SELECT statement to retrieve the data from the CTE.

3. Description of parts:

- CTE 'result':
  - Select the track name using a multiIf function that maps selected_track_id to a string representing the track name.
  - Include the registration_date as 'cohort'.
  - Calculate the 'metric' by counting the number of 'completed_step' actions that occurred the day after the registration date and dividing it by the unique count of user IDs.
  - Filter the data from the 'hyperskill.content' table where the date is within 14 days before and 7 days after '2023-09-18', the registration_date is within the same range, the action is either 'view' or 'completed_step', track_id is not 0, and flags for is_biased, is_guest, and is_superuser are all 0.
  - Group the results by 'cohort' and 'track'.
  - Order the results by 'cohort'.

- Final SELECT statement:
  - Select all columns from the CTE 'result'.","Can we get a report on how well new users are engaging with our tracks? Specifically, I'd like to see the ratio of completed steps the day after they sign up, broken down by the track they chose and their registration date."
"-- The number of user interactions with different elements on the theory and practice screens.

-- in the theory tab:
--
-- Comments
-- Hints
-- User links
-- Show discussion
WITH

theories AS (

    SELECT
        step_id,
        topic_id
    FROM hyperskill.stg_steps
    WHERE step_type = 'text'

),

actions_stat_on_theory AS (

    SELECT
        uniqExact(user_id)                               AS visited_users,
        uniqExactIf(user_id, target = 'comment')         AS comment_click_users,
        uniqExactIf(user_id, target = 'useful_link')     AS useful_link_click_users,
        uniqExactIf(user_id, target = 'show_discussion') AS show_discussion_click_users,
        comment_click_users / visited_users              AS comment_click_rate,
        useful_link_click_users / visited_users          AS useful_link_click_rate,
        show_discussion_click_users / visited_users      AS show_discussion_click_rate
    FROM hyperskill.content
    WHERE date >= today() - interval 6 month
        AND action IN ('click')
        AND splitByChar('#', splitByChar('/', page)[4])[1] IN (SELECT step_id FROM theories)

),

objects_stat_on_theory AS (

    SELECT
        round(avg(comment_click_rate), 3)         AS avg_comment_click_rate,
        round(avg(useful_link_click_rate), 3)     AS avg_useful_link_click_rate,
        round(avg(show_discussion_click_rate), 3) AS avg_show_discussion_click_rate
    FROM actions_stat_on_theory

)

SELECT *
FROM objects_stat_on_theory;

-- in the practice tab:
--
-- See hint
-- Report a typo (это не кнопка)
-- Comments
-- Hints
-- User links
-- Solution (есть только в кодовых задачах)
-- Show discussion
WITH

problems AS (

    SELECT
        step_id,
        topic_id
    FROM hyperskill.stg_steps
    WHERE step_type != 'text'
        AND topic_id > 0

),

actions_stat_on_problems AS (

    SELECT
        uniqExact(user_id)                               AS visited_users,
        uniqExactIf(user_id, target = 'comment')         AS comment_click_users,
        uniqExactIf(user_id, target = 'useful_link')     AS useful_link_click_users,
        uniqExactIf(user_id, target = 'show_discussion') AS show_discussion_click_users,
        uniqExactIf(user_id, target = 'solutions')       AS solutions_click_users,
        uniqExactIf(user_id, target = 'hint')            AS comments_hint_click_users,
        uniqExactIf(user_id, target = 'see_hint')        AS see_hint_click_users,
        comment_click_users / visited_users              AS comment_click_rate,
        useful_link_click_users / visited_users          AS useful_link_click_rate,
        show_discussion_click_users / visited_users      AS show_discussion_click_rate,
        solutions_click_users / visited_users            AS solutions_click_rate,
        comments_hint_click_users / visited_users        AS comments_hint_click_rate,
        see_hint_click_users / visited_users             AS see_hint_click_rate
    FROM hyperskill.content
    WHERE date >= today() - interval 6 month
        AND action IN ('click')
        AND splitByChar('#', splitByChar('/', page)[4])[1] IN (
            SELECT step_id FROM problems)
),

objects_stat_on_problems AS (

    SELECT
        round(avg(comment_click_rate), 3)         AS avg_comment_click_rate,
        round(avg(useful_link_click_rate), 3)     AS avg_useful_link_click_rate,
        round(avg(show_discussion_click_rate), 3) AS avg_show_discussion_click_rate,
        round(avg(solutions_click_rate), 3)       AS avg_solutions_click_rate,
        round(avg(comments_hint_click_rate), 3)   AS avg_comments_hint_click_rate,
        round(avg(see_hint_click_rate), 3)        AS avg_see_hint_click_rate

    FROM actions_stat_on_problems

)

SELECT *
FROM objects_stat_on_problems;
","### Expected Query Result
The expected result of the query is two separate sets of average click rates for different user interactions with elements on the theory and practice screens. The first set will include average click rates for comments, useful links, and show discussion on the theory tab. The second set will include average click rates for comments, useful links, show discussion, solutions, and hints on the practice tab.

### Logical Parts of the Query
The query can be broken down into the following logical parts:
1. Identification of theory steps
2. Calculation of user interaction statistics on theory steps
3. Aggregation of average click rates on theory steps
4. Identification of problem (practice) steps
5. Calculation of user interaction statistics on problem steps
6. Aggregation of average click rates on problem steps

### Part Descriptions

#### 1. Identification of theory steps
- Select `step_id` and `topic_id` from the `hyperskill.stg_steps` table.
- Filter the results where `step_type` is equal to 'text' to identify theory steps.

#### 2. Calculation of user interaction statistics on theory steps
- Calculate the unique count of `user_id` who visited theory steps as `visited_users`.
- Calculate the unique count of `user_id` who clicked on comments, useful links, and show discussion as `comment_click_users`, `useful_link_click_users`, and `show_discussion_click_users` respectively.
- Filter the `hyperskill.content` table for actions within the last 6 months and for 'click' actions.
- Ensure that the `page` attribute corresponds to the `step_id` from the previously identified theory steps.

#### 3. Aggregation of average click rates on theory steps
- Calculate the average click rates for comments, useful links, and show discussion by dividing the respective click user counts by the visited user count.
- Round these average rates to three decimal places.

#### 4. Identification of problem (practice) steps
- Select `step_id` and `topic_id` from the `hyperskill.stg_steps` table.
- Filter the results where `step_type` is not equal to 'text' and `topic_id` is greater than 0 to identify problem steps.

#### 5. Calculation of user interaction statistics on problem steps
- Calculate the unique count of `user_id` who visited problem steps as `visited_users`.
- Calculate the unique count of `user_id` who clicked on comments, useful links, show discussion, solutions, and hints as `comment_click_users`, `useful_link_click_users`, `show_discussion_click_users`, `solutions_click_users`, and `comments_hint_click_users` respectively.
- Filter the `hyperskill.content` table for actions within the last 6 months and for 'click' actions.
- Ensure that the `page` attribute corresponds to the `step_id` from the previously identified problem steps.

#### 6. Aggregation of average click rates on problem steps
- Calculate the average click rates for comments, useful links, show discussion, solutions, and hints by dividing the respective click user counts by the visited user count.
- Round these average rates to three decimal places.","Can you provide me with the average engagement rates for different interactive elements on our theory and practice pages? Specifically, I'm interested in the average click rates for comments, useful links, and discussions on the theory pages, as well as the same elements plus solutions and hints on the practice pages, over the last six months."
"--
WITH

filtered_users AS (

    SELECT user_id
    FROM hyperskill_private.users
    WHERE is_biased = 0  -- Not staff
      AND is_superuser = 0  -- and not superusers
      AND user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased)  -- additional filter for users_is_biased
      AND is_testee = 1  -- agree to be a testee
      AND dictGetString(
              'hyperskill.alt_cities_country_dict',
              'name',
              toUInt64(country_by_ip_id)
          ) NOT IN ('Russia', 'Ukraine', 'Belarus')
      AND sub_personal_str_map['ownerCountry'] NOT IN ('RU', 'UA', 'BY')  -- b) Not from Russia, Ukraine, Belarus
      AND date_registered >= '2023-06-01'  -- Registered since 2023-06-01

),

talg AS (
    -- get ""tell about your level and goal"" poll data
    SELECT
        user_id
    FROM hyperskill.polls
    WHERE poll_id = 4
        AND question_1 IN ('1', '2')

),

users AS (

    SELECT
        user_id,
        dictGetString('hyperskill_private.users_dict', 'email', toUInt64(user_id)) AS email
    FROM hyperskill.content

    WHERE action = 'completed_step'
      AND user_id IN (SELECT user_id FROM filtered_users)

    GROUP BY user_id
    HAVING countIf(date, action = 'completed_step' AND step_type <> 'text'
        AND date BETWEEN today() - 62 + 1 AND today() - 1) > 0
        AND countIf(date, selected_track_id IN (2, 6, 11, 28, 29, 30, 54, 44, 58, 59, 79, 62)) > 0 -- learning / having learned on Python tracks

)

SELECT
    user_id,
    email
FROM users;","1. The expected query result is a list of user IDs and their corresponding emails for users who meet specific criteria.

2. The query is broken down into three logical parts: filtered_users, talg, and users.

3. Part: filtered_users
- Select the user_id from the hyperskill_private.users table.
- Filter out users who are staff (is_biased = 0), superusers (is_superuser = 0), and those listed in the hyperskill.users_is_biased table.
- Include only users who have agreed to be testees (is_testee = 1).
- Exclude users from Russia, Ukraine, and Belarus based on both country_by_ip_id and sub_personal_str_map['ownerCountry'].
- Consider only users who registered on or after June 1, 2023.

4. Part: talg
- Select user_id from the hyperskill.polls table.
- Include only data related to the poll with poll_id = 4.
- Filter to include only responses where question_1 is '1' or '2'.

5. Part: users
- Select user_id and email from the hyperskill.content table.
- The email is retrieved using the dictGetString function and the users_dict dictionary.
- Include only actions that are 'completed_step'.
- The user_id must be in the list obtained from the filtered_users part.
- Group the results by user_id.
- Having clause filters to include users who have completed non-text steps in the last 62 days and have selected tracks that are Python-related.
","Can you provide me with a list of user emails who are not staff or superusers, have agreed to be test subjects, are not from Russia, Ukraine, or Belarus, registered after June 1st, 2023, answered '1' or '2' on question 1 of poll 4, have completed non-text steps in the last 62 days, and are on Python-related tracks?"
"WITH 16 AS retention_depth
SELECT
    week_number,
    toDate(week_number) AS week_number_date,
    user_id,
    segment,
    retention,
    retentions
FROM (
    SELECT
        user_id,
        dictGetString(
            'hyperskill_reports.users_first_platform_last_185_d__dict',
            'first_platform',
            toUInt64(user_id)
        ) AS first_platform,
        toDate(
            dictGetDateTime(
                'hyperskill_reports.users_mobile_apps_first_login__dict',
                'first_login_dt',
                toUInt64(user_id)
            )
        ) AS first_login_date,
        toDate(
            dictGetDateTime(
                'hyperskill_private.users_dict',
                'date_registered',
                toUInt64(user_id)
            )
        ) AS registration_date,
        multiIf(
            first_platform IN ('iOS', 'Android'),
                'Registered via app',
            (first_login_date - toDate(registration_date) AS days_from_registration) <= 3,
                '[0-3] days old',
            days_from_registration > 3 AND days_from_registration <= 7,
                '(3-7] days old',
            days_from_registration > 7 AND days_from_registration <= 30,
                '(7-30] days old',
            days_from_registration > 30 AND days_from_registration <= 90,
                '(30-90] days old', '91+ days old'
        ) AS segment,
        retention(
            (date >= first_login_date) AND (date <= (first_login_date + 7)),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 8))
                AND (date <= (first_login_date + 14))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 15))
                AND (date <= (first_login_date + 21))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 22))
                AND (date <= (first_login_date + 28))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 29))
                AND (date <= (first_login_date + 35))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 36))
                AND (date <= (first_login_date + 42))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 43))
                AND (date <= (first_login_date + 49))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 50))
                AND (date <= (first_login_date + 56))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 57))
                AND (date <= (first_login_date + 63))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 64))
                AND (date <= (first_login_date + 70))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 71))
                AND (date <= (first_login_date + 77))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 78))
                AND (date <= (first_login_date + 84))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 85))
                AND (date <= (first_login_date + 91))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 92))
                AND (date <= (first_login_date + 98))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 99))
                AND (date <= (first_login_date + 105))),
            (action IN ('completed_submission', 'failed_submission',
                        'rejected_submission'))
                AND ((date >= (first_login_date + 106))
                AND (date <= (first_login_date + 112)))
        ) AS retentions
    FROM hyperskill.content
    WHERE date >= today() - toIntervalDay(28 * 6)
        AND date < today()
        AND platform IN ('Android', 'iOS')
        AND is_guest = 0
        AND first_login_date >= today() - toIntervalDay(28 * 6)
        AND first_login_date <= today() - 7 - 1
        AND action IN (
            'view', 'logged_in_user', 'registered_user', 'completed_submission',
            'failed_submission', 'rejected_submission'
        )
        AND step_type != 'text'
        AND user_id NOT IN (
            SELECT user_id
            FROM hyperskill.users_is_biased
        )
        AND first_login_date > toDate(0)
    GROUP BY user_id
) AS content_data
ARRAY JOIN
    retentions AS retention,
    range(retention_depth) AS week_number;","The expected result of the query is a list of users with their respective week numbers, the date corresponding to those week numbers, user IDs, segments, retention status, and an array of retention data over a certain period.

The query can be broken down into the following logical parts:
1. Common Table Expression (CTE) definition
2. Inner subquery
3. Outer query with ARRAY JOIN

1. CTE definition:
- Define a CTE with a constant value representing the depth of retention data to be analyzed.

2. Inner subquery:
- Select user-related data from the 'hyperskill.content' table.
- Retrieve the user's first platform using the 'dictGetString' function from a dictionary.
- Get the user's first login date and registration date using the 'dictGetDateTime' function from dictionaries.
- Calculate the number of days from registration and categorize users into segments based on this duration.
- Use a custom 'retention' function to calculate retention data based on user actions within specific time frames after the first login date.
- Filter the data based on conditions such as date range, platform, guest status, first login date, action types, step type, and exclusion of biased users.
- Group the results by 'user_id'.

3. Outer query with ARRAY JOIN:
- Select the necessary columns from the inner subquery.
- Use 'ARRAY JOIN' to expand the 'retentions' array into multiple rows, one for each element in the array.
- Calculate the 'week_number_date' by converting the 'week_number' to a date.
- Filter the results based on the retention depth defined in the CTE.","Can you provide me with a breakdown of user retention data over a specific period? I need to see which week each user is in, their registration and login dates, user segments based on how long they've been registered, and their retention status. Also, I'd like to have an array of retention data for each user to analyze their activity over time."
"-- https://vyahhi.myjetbrains.com/youtrack/issue/AN-1818/Q3-2023-OKR-dashboard-for-Habit-team
CREATE OR REPLACE VIEW hyperskill_reports.habit_in_week_activity
AS
WITH

user_data AS (

    SELECT
        toMonday(date) AS week,
        user_id,
        uniqExact(date) AS active_days
    FROM hyperskill.content
    WHERE date >= toMonday(today() - 28 * 7)
        AND date < toMonday(today())
        AND action = 'completed_submission'
    GROUP BY week, user_id

),

agg AS (

    SELECT
        week,
        avg(active_days) AS avg_active_days
    FROM user_data
    GROUP BY week

)

SELECT *
FROM agg;

-- Percentage of yesterday’s active users who are NOT active today
CREATE OR REPLACE VIEW hyperskill_reports.habit_churn
AS
WITH

today() - 28 * 8 AS start_from,

user_data AS (

    SELECT
        user_id,
        groupUniqArray(date) AS dates,
        dictGetDateTime(
            'hyperskill_private.users_dict', 'date_registered', toUInt64(user_id)
        ) AS registration_date
    FROM hyperskill.content
    WHERE date >= start_from
        AND action = 'completed_submission'
        AND registration_date >= start_from
    GROUP BY user_id

),

agg AS (

    SELECT
        arrayJoin(
            arrayMap(
                i -> today() - toIntervalDay(i),
                range(1, 28 * 7)
            )
        ) AS period,
        uniqExactIf(
            user_id,
            (arrayExists(
                date -> date = period - 1,
                dates
            ) AS was_active_previous_day)
        ) AS previous_period_active_users,
        uniqExactIf(
            user_id,
            was_active_previous_day
                AND (
                    arrayExists(
                        date -> date = period,
                        dates
                    ) AS is_active_during_period
                )
        ) AS current_period_active_users_from_previous_period
    FROM user_data
    WHERE period - toDate(registration_date) > 3
    GROUP BY period

),

result AS (

    SELECT
        period,
        previous_period_active_users,
        current_period_active_users_from_previous_period,
        (previous_period_active_users
             - current_period_active_users_from_previous_period)
            / previous_period_active_users AS churn
    FROM agg

)

SELECT *
FROM result;


-- Percentage of yesterday’s active users who are NOT active today
CREATE OR REPLACE VIEW hyperskill_reports.habit_churn_segmented
AS
WITH

today() - 28 * 8 AS start_from,

user_data AS (

    SELECT
        user_id,
        groupUniqArray(date) AS dates,
        dictGetDateTime(
            'hyperskill_private.users_dict', 'date_registered', toUInt64(user_id)
        ) AS registration_date
    FROM hyperskill.content
    WHERE date >= start_from
        AND action = 'completed_submission'
        AND registration_date >= start_from
    GROUP BY user_id

),

agg AS (

    SELECT
        arrayJoin(
            arrayMap(
                i -> today() - toIntervalDay(i),
                range(1, 28 * 7)
            )
        ) AS period,
        multiIf(
            (period - toDate(registration_date) AS days_from_registration) <= 3,
            '[0-3] days old',
            days_from_registration > 3 AND days_from_registration <= 7,
            '(3-7] days old',
            days_from_registration > 7 AND days_from_registration <= 30,
            '(7-30] days old',
            days_from_registration > 30 AND days_from_registration <= 90,
            '(30-90] days old',
            '91+ days old'
        ) AS segment,
        uniqExactIf(
            user_id,
            (arrayExists(
                date -> date = period - 1,
                dates
            ) AS was_active_previous_day)
        ) AS previous_period_active_users,
        uniqExactIf(
            user_id,
            was_active_previous_day
                AND (
                    arrayExists(
                        date -> date = period,
                        dates
                    ) AS is_active_during_period
                )
        ) AS current_period_active_users_from_previous_period
    FROM user_data
    GROUP BY period, segment

),

result AS (

    SELECT
        period,
        segment,
        previous_period_active_users,
        current_period_active_users_from_previous_period,
        (previous_period_active_users
             - current_period_active_users_from_previous_period)
            / previous_period_active_users AS churn
    FROM agg

)

SELECT *
FROM result;
","1. The first query creates a view named 'habit_in_week_activity' which will contain weekly averages of active days per user for the last 28 weeks.

2. The query is broken down into two logical parts:
   - user_data: This part collects the number of unique active days per user for each week within the last 28 weeks.
   - agg: This part calculates the average number of active days across all users for each week.

3. For 'user_data':
   - Select the start of the week (Monday) for each date as 'week'.
   - Group the data by 'week' and 'user_id'.
   - Count the unique number of days the user was active ('active_days') using the 'uniqExact' function on the 'date' column.
   - Filter the actions to only include 'completed_submission'.
   - Ensure the date range is between today minus 28 weeks and the start of the current week.

4. For 'agg':
   - Group the data by 'week'.
   - Calculate the average number of active days ('avg_active_days') using the 'avg' function on the 'active_days' column from the 'user_data' part.

5. The final select statement retrieves all columns from the 'agg' part to form the view.","Can we get an analysis on user engagement over the last 6 months? Specifically, I'm interested in understanding the average number of days per week that users are actively completing submissions. It would be helpful to see this trend on a weekly basis to track any changes in user habits."
"--
WITH

segment AS (

    SELECT
        email,
        date_registered,
        hypercoins
    FROM hyperskill_private.users
    WHERE user_id NOT IN (SELECT * FROM hyperskill.users_is_biased)
        AND (dictGetString('hyperskill.alt_cities_country_dict', 'name', toUInt64(country_by_ip_id)) AS country)
            NOT IN ('Russia', 'Belarus')
    ORDER BY hypercoins DESC
    LIMIT 20000

)

SELECT *
FROM segment;","1. Describe the expected query result: The query will return a list of users with their email, date_registered, and hypercoins, filtered to exclude users from a specific subset and certain countries, ordered by the number of hypercoins in descending order, limited to the top 20,000 users.

2. Break down the query into logical parts: The query consists of a single Common Table Expression (CTE) named 'segment'.

3. Description of the CTE 'segment':
- Select the columns 'email', 'date_registered', and 'hypercoins' from the 'hyperskill_private.users' table.
- Exclude users whose 'user_id' appears in the 'hyperskill.users_is_biased' table.
- Use the 'dictGetString' function to retrieve the country name associated with the 'country_by_ip_id' column, and exclude users from 'Russia' and 'Belarus'.
- Order the results by the 'hypercoins' column in descending order.
- Limit the result to the top 20,000 users based on the 'hypercoins' column.

4. Description of the final SELECT statement:
- Select all columns from the CTE 'segment' without any additional filtering or ordering, as it has already been done within the CTE.","Can you provide me with a list of our top 20,000 users by hypercoins, excluding any users from Russia and Belarus and those flagged in our biased user table? I need their emails, registration dates, and hypercoin balances for a marketing analysis."
"-- https://vyahhi.myjetbrains.com/youtrack/issue/AN-1818/Q3-2023-OKR-dashboard-for-Habit-team
CREATE OR REPLACE VIEW hyperskill_reports.habit_in_week_activity
AS
WITH

user_data AS (

    SELECT
        toMonday(date) AS week,
        user_id,
        uniqExact(date) AS active_days
    FROM hyperskill.content
    WHERE date >= toMonday(today() - 28 * 7)
        AND date < toMonday(today())
        AND action = 'completed_submission'
    GROUP BY week, user_id

),

agg AS (

    SELECT
        week,
        avg(active_days) AS avg_active_days
    FROM user_data
    GROUP BY week

)

SELECT *
FROM agg;

-- Percentage of yesterday’s active users who are NOT active today
CREATE OR REPLACE VIEW hyperskill_reports.habit_churn
AS
WITH

today() - 28 * 8 AS start_from,

user_data AS (

    SELECT
        user_id,
        groupUniqArray(date) AS dates
    FROM hyperskill.content
    WHERE date >= start_from
        AND action = 'completed_submission'
        AND dictGetDateTime(
            'hyperskill_private.users_dict', 'date_registered', toUInt64(user_id)
        ) >= start_from
    GROUP BY user_id

),

agg AS (

    SELECT
        arrayJoin(
            arrayMap(
                i -> today() - toIntervalDay(i),
                range(1, 28 * 7)
            )
        ) AS period,
        uniqExactIf(
            user_id,
            (arrayExists(
                date -> date = period - 1,
                dates
            ) AS was_active_previous_day)
        ) AS previous_period_active_users,
        uniqExactIf(
            user_id,
            was_active_previous_day
                AND (
                    arrayExists(
                        date -> date = period,
                        dates
                    ) AS is_active_during_period
                )
        ) AS current_period_active_users_from_previous_period
    FROM user_data
    GROUP BY period

),

result AS (

    SELECT
        period,
        previous_period_active_users,
        current_period_active_users_from_previous_period,
        (previous_period_active_users
             - current_period_active_users_from_previous_period)
            / previous_period_active_users AS churn
    FROM agg

)

SELECT *
FROM result;","1. The first query creates or replaces a view named 'habit_in_week_activity' in the 'hyperskill_reports' schema.

2. The expected result of the first query is a list of weeks with the average number of active days per user for each week.

3. The first query consists of two logical parts:
   a. user_data
   b. agg

4. 'user_data' part description:
   - Select the Monday of the week for each date as 'week'.
   - Select the 'user_id'.
   - Calculate the unique count of active days for each user within a week as 'active_days'.
   - Filter the data from the 'hyperskill.content' table where the 'date' is within the last 28 weeks and before the current week's Monday.
   - Include only records where the 'action' is 'completed_submission'.
   - Group the results by 'week' and 'user_id'.

5. 'agg' part description:
   - Select the 'week'.
   - Calculate the average number of 'active_days' for each week as 'avg_active_days'.
   - Group the results by 'week'.

6. The second query creates or replaces a view named 'habit_churn' in the 'hyperskill_reports' schema.

7. The expected result of the second query is a list of periods with the number of users active the previous day, the number of those users who are also active during the current period, and the churn rate.

8. The second query consists of three logical parts:
   a. user_data
   b. agg
   c. result

9. 'user_data' part description for the second query:
   - Select the 'user_id'.
   - Aggregate the dates of completed submissions into an array for each user as 'dates'.
   - Filter the data from the 'hyperskill.content' table where the 'date' is within the last 28 weeks starting from 8 weeks ago.
   - Include only records where the 'action' is 'completed_submission' and the user's registration date is within the same period.
   - Group the results by 'user_id'.

10. 'agg' part description for the second query:
    - Generate a series of dates representing the period of interest as 'period'.
    - Count the unique users who were active the previous day as 'previous_period_active_users'.
    - Count the unique users who were active the previous day and are also active during the current period as 'current_period_active_users_from_previous_period'.
    - Group the results by 'period'.

11. 'result' part description for the second query:
    - Select the 'period'.
    - Select the count of 'previous_period_active_users'.
    - Select the count of 'current_period_active_users_from_previous_period'.
    - Calculate the churn rate as 'churn'.","Can we get a report on how our users' engagement has changed over the last 28 weeks? Specifically, I'm interested in the average number of active days per user each week, and also in understanding our churn rate over time. It would be helpful to see how many users stay active from one period to the next within this timeframe."
"-- dict
-- create mautic leads dict view
CREATE VIEW IF NOT EXISTS hyperskill_reports.mautic_leads
AS
SELECT DISTINCT
    id,
    hs_id
FROM hyperskill_mautic.leads
WHERE date_added > today() - 185;

-- create mautic leads dict
DROP DICTIONARY IF EXISTS hyperskill_reports.mautic_leads_dict;
CREATE DICTIONARY IF NOT EXISTS hyperskill_reports.mautic_leads_dict
    (
    `id` Int64,
    `hs_id` Int64
    )
    PRIMARY KEY id
    SOURCE(
        CLICKHOUSE(
            HOST 'localhost'
            PORT 9000
            USER 'hyperskill_readonly'
            PASSWORD 'a7klZE43bP3XqVE4'
            DB 'hyperskill_reports'
            TABLE 'mautic_leads'
        )
    )
    LIFETIME(MIN 3600 MAX 86400)
    LAYOUT(HASHED(PREALLOCATE 0));

-- check dict
SELECT
    id,
    hs_id
FROM hyperskill_reports.mautic_leads_dict;

-- query
WITH

map(
    'day0', 530,
    'day1', 525,
    'day2', 526,
    'day3', 527,
    'day4', 528,
    'day5', 529
) AS email_map,
'day0' AS filter_value,  -- '{{ ''.join(filter_values('values')) }}'
1 AS product_months_ago,

events AS (

    SELECT
        user_id,
        dictGetDateTime(
            'hyperskill_private.users_dict', 'date_registered', toUInt64(user_id)
        ) AS date_registered,
        action,
        assumeNotNull(solving_context) AS context
    FROM hyperskill.content
    WHERE date >= toMonday(today() - 28 * product_months_ago)
        AND action IN ('view', 'completed_step', 'completed_topic')
        AND date_registered >= toMonday(today() - 28 * product_months_ago)

    UNION ALL

    SELECT
        dictGetInt64(
                'hyperskill_reports.mautic_leads_dict', 'hs_id', toUInt64(lead_id)
            ) AS user_id,
        dictGetDateTime(
            'hyperskill_private.users_dict', 'date_registered', toUInt64(user_id)
        ) AS date_registered,
        'sent_or_read_email' AS action,
        assumeNotNull(toString(date_sent) || ',' || toString(date_read)) AS context
    FROM hyperskill_mautic.email_stats
    WHERE date_sent >= toMonday(today() - 28 * product_months_ago)
        AND date_registered >= toMonday(today() - 28 * product_months_ago)
        AND email_id IN (email_map[filter_value])

    UNION ALL

    SELECT
        dictGetInt64(
            'hyperskill_reports.mautic_leads_dict', 'hs_id', toUInt64(lead_id)
        ) AS user_id,
        dictGetDateTime(
            'hyperskill_private.users_dict', 'date_registered', toUInt64(user_id)
        ) AS date_registered,
        'hit_page' AS action,
        assumeNotNull('') AS context
    FROM hyperskill_mautic.page_hits
    WHERE date_hit >= toMonday(today() - 28 * product_months_ago)
        AND date_registered >= toMonday(today() - 28 * product_months_ago)
        AND email_id IN (email_map[filter_value])

),

conversions_data AS (

    SELECT
        user_id,
        dictGetDateTime(
            'hyperskill_private.users_dict', 'date_registered', toUInt64(user_id)
        ) AS date_registered,
        retention(
            1 = 1,
            action = 'sent_or_read_email'
                AND toDateTime(splitByChar(',', context)[1]) > toMonday(today() - 28 * product_months_ago),
            action = 'sent_or_read_email'
                AND toDateTime(splitByChar(',', context)[2]) > toMonday(today() - 28 * product_months_ago),
            action = 'hit_page',
            action = 'completed_step' AND context IN ('', 'default'),
            action = 'completed_topic' AND context IN ('by_steps', 'default')
        ) AS conversions
    FROM events
    GROUP BY user_id

),

funnel AS (

    SELECT
        toMonday(date_registered) AS week_cohort,
        sum(conversions[1]) AS users,
        sum(conversions[2]) AS sent_emails,
        sumIf(conversions[3], conversions[2]) / sent_emails AS read_emails,
        sumIf(conversions[4], conversions[3]) / sent_emails AS hit_page,
        sumIf(conversions[5], conversions[4]) / sent_emails AS completed_step_in_topic,
        sumIf(
            conversions[6], conversions[4] AND conversions[4]
        ) / sent_emails AS completed_topic_by_steps
    FROM conversions_data
    GROUP BY week_cohort

)

SELECT *
FROM funnel
ORDER BY week_cohort DESC;","1. Expected Query Result:
- A list of weekly cohorts with the number of users, sent emails, read emails, page hits, completed steps in topics, and completed topics by steps.

2. Logical Parts:
- Creation of a view named 'mautic_leads'.
- Creation of a dictionary named 'mautic_leads_dict'.
- Checking the dictionary with a SELECT query.
- Defining a map of email identifiers and a filter value.
- Defining a variable for product months ago.
- Creating a Common Table Expression (CTE) named 'events'.
- Creating a CTE named 'conversions_data'.
- Creating a CTE named 'funnel'.
- Final SELECT query to retrieve data from the 'funnel' CTE.

3. Part Descriptions:
- View 'mautic_leads': Select distinct 'id' and 'hs_id' from 'leads' table where 'date_added' is within the last 185 days.
- Dictionary 'mautic_leads_dict': Create a dictionary with 'id' and 'hs_id' as columns, using the 'mautic_leads' view as the source.
- Check Dictionary: Select 'id' and 'hs_id' from the 'mautic_leads_dict' to verify its contents.
- Email Map and Filter Value: Define a map with email identifiers and a variable to hold the filter value for the emails.
- Product Months Ago: Define a variable to calculate the date range for the events.
- CTE 'events': Combine data from different actions ('view', 'completed_step', 'completed_topic', 'sent_or_read_email', 'hit_page') for users registered within the date range.
- CTE 'conversions_data': Calculate conversion metrics for each user based on their actions.
- CTE 'funnel': Aggregate conversion data by weekly cohorts.
- Final SELECT: Retrieve and order the aggregated data by descending weeks from the 'funnel' CTE.","Can we get a weekly breakdown of user engagement metrics? Specifically, I'm interested in the number of users, emails sent and read, website interactions, and progress in our educational topics over the past six months."
"-- https://vyahhi.myjetbrains.com/youtrack/issue/AN-1261

DROP VIEW IF EXISTS hyperskill_reports.learning_users__view;
--
CREATE OR REPLACE VIEW hyperskill_reports.learning_users
AS
SELECT
    date,
    user_id,
    multiIf(
        subscription_type = 'personal', 'Personal',
        subscription_type IN ('team member', 'commercial'), 'Team Member',
        subscription_type = 'freemium', 'Freemium',
        subscription_type = 'premium', 'Premium',
        'Other'
        ) AS user_type
FROM hyperskill.content
WHERE date BETWEEN today() - 28 * 6 AND today() - 1
  AND user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased)
  AND action IN ('failed_submission', 'completed_submission', 'rejected_submission')
  AND step_type != 'text';


DROP VIEW IF EXISTS hyperskill_reports.daily_learning_users__view;
CREATE OR REPLACE VIEW hyperskill_reports.daily_learning_users
AS
SELECT
    date,
    user_type,
    uniqExact(user_id) AS users
FROM hyperskill_reports.learning_users
GROUP BY date, user_type;
","1. Describe the expected query result: The query is expected to create a view named 'hyperskill_reports.daily_learning_users' that will contain aggregated data about users' learning activities on a daily basis, grouped by the date and the type of user (Personal, Team Member, Freemium, Premium, or Other). Each row will represent a unique combination of date and user type, along with the count of unique users who had learning activities on that date for that user type.

2. Break down the query into logical parts: The query consists of two main parts - the creation of the 'learning_users' view and the creation of the 'daily_learning_users' view.

3. Part descriptions:

Part 1: Creation of 'learning_users' view
- Drop the existing view 'hyperskill_reports.learning_users__view' if it exists.
- Create or replace the view 'hyperskill_reports.learning_users' with the following specifications:
  - Select the 'date', 'user_id', and a derived column 'user_type' based on the 'subscription_type' column using a multiIf function to categorize the subscription types into 'Personal', 'Team Member', 'Freemium', 'Premium', or 'Other'.
  - Filter the data to include records from the last 28 weeks excluding the current day.
  - Exclude 'user_id' that are present in the 'hyperskill.users_is_biased' table.
  - Include only actions that are 'failed_submission', 'completed_submission', or 'rejected_submission'.
  - Exclude steps of type 'text'.

Part 2: Creation of 'daily_learning_users' view
- Drop the existing view 'hyperskill_reports.daily_learning_users__view' if it exists.
- Create or replace the view 'hyperskill_reports.daily_learning_users' with the following specifications:
  - Select the 'date', 'user_type', and count the unique 'user_id' as 'users'.
  - Group the results by 'date' and 'user_type' to get the daily count of unique users for each user type.","Can you provide me with a report that shows the number of unique users engaged in learning activities each day, broken down by their subscription type? Please make sure to exclude any biased user data and only count activities related to submissions, excluding text-based steps, for the past 28 weeks."
"--
WITH

subs_data As (

    SELECT
        user_id,
        date_registered,
        if(
            isNull(sub_personal_dts['created_at_min']),
                sub_premium_dts['created_at_min'],
            sub_personal_dts['created_at_min']
        ) AS created_at_min,
        (created_at_min - date_registered) / (3600 * 24) AS days_to_subscribe
    FROM hyperskill_private.users
    WHERE (
        sub_personal_dts != '{}'
            OR sub_premium_dts != '{}'
        )
        AND date_registered > today() - 185
        AND days_to_subscribe >= -1

),

stats AS (

    SELECT quantiles(.25, .5, .75, .9, .99)(days_to_subscribe) AS quantiles
    FROM subs_data

)

-- make output and col names more human readable
SELECT
    round(quantiles[1], 2) AS q_25_days,
    round(quantiles[2], 2) AS q_50_days,
    round(quantiles[3], 2) AS q_75_days,
    round(quantiles[4], 2) AS q_90_days,
    round(quantiles[5], 2) AS q_99_days
FROM stats;","1. The expected result of the query is a set of quantile values representing the time it takes for users to subscribe after registering. These quantiles are at the 25th, 50th, 75th, 90th, and 99th percentiles.

2. The query is broken down into two logical parts: the 'subs_data' Common Table Expression (CTE) and the 'stats' CTE.

3. 'subs_data' CTE:
   - Select the 'user_id', 'date_registered', and the minimum creation date between 'sub_personal_dts['created_at_min']' and 'sub_premium_dts['created_at_min']' as 'created_at_min'.
   - Calculate the difference in days between 'created_at_min' and 'date_registered' as 'days_to_subscribe'.
   - Filter users who have either a personal or premium subscription and who registered within the last 185 days.
   - Ensure that 'days_to_subscribe' is greater than or equal to -1.

4. 'stats' CTE:
   - Calculate the quantiles for the 'days_to_subscribe' column from the 'subs_data' CTE.

5. Final SELECT:
   - Round the quantile values to two decimal places and alias them as 'q_25_days', 'q_50_days', 'q_75_days', 'q_90_days', and 'q_99_days' respectively.
   - Retrieve these rounded quantile values from the 'stats' CTE.","Can you provide me with the recent statistics on how quickly users are converting to subscribers after they register? I'm particularly interested in the typical time frames, like the average and the range for the majority, as well as some insights on outliers. It would be great to have this data for the last six months."
"--
WITH

target_users as (
    -- users who have completed at least 1 `dailystep` during the ""hour of code""
    SELECT user_id
    FROM hyperskill_mariadb.steps_dailystep
    WHERE state = 1
      AND day BETWEEN '2022-12-05' AND '2022-12-11'  -- hour of code event period
    GROUP BY user_id
    HAVING uniqExact(day) = 7

),

emails AS (
    
    SELECT verified_primary_email
    FROM hyperskill_private.users
    WHERE dictGetString(
            'hyperskill.alt_cities_country_dict', 'name', toUInt64(country_by_ip_id)
            ) NOT IN ('Russia', 'Belarus')
        AND id IN target_users  -- filter by target users
        AND verified_primary_email != ''
        AND id NOT IN (SELECT * FROM hyperskill.users_is_biased)
                    
)

SELECT *
FROM emails;","1. The expected result of the query is a list of verified primary email addresses from users who have completed at least one 'dailystep' every day during the 'hour of code' event period, excluding users from Russia and Belarus, and also excluding users who are marked as biased in the 'users_is_biased' table.

2. The query is broken down into two logical parts:
   a. target_users
   b. emails

3. Part a - target_users:
   - Select the 'user_id' from the 'steps_dailystep' table.
   - Filter records where 'state' equals 1.
   - Ensure the 'day' falls within the specified event period (between '2022-12-05' and '2022-12-11').
   - Group the results by 'user_id'.
   - Apply a HAVING clause to filter only those users who have a unique count of 'day' equal to 7, indicating they completed a step every day of the event.

4. Part b - emails:
   - Select the 'verified_primary_email' from the 'users' table.
   - Use the 'dictGetString' function to get the country name associated with the 'country_by_ip_id' and exclude emails from users in 'Russia' and 'Belarus'.
   - Filter the users by checking if their 'id' is in the list of 'target_users' obtained from part a.
   - Ensure that the 'verified_primary_email' is not an empty string.
   - Exclude users whose 'id' is present in the 'users_is_biased' table.

5. Finally, select all records from the 'emails' CTE (Common Table Expression) to get the desired list of email addresses.","Can you provide me with a list of verified primary email addresses for users who participated every day in the 'hour of code' event from December 5th to 11th, 2022? Please exclude any users from Russia and Belarus, and also those who are flagged as biased in our system."
"WITH

-- get all users who clicked on ide or install_ide
result AS (
    
    SELECT DISTINCT user_id
    FROM hyperskill.content
    WHERE date >= today() - toIntervalMonth(1)
        AND action = 'click'
        AND target IN ('ide', 'install_ide')
        AND user_id NOT IN (SELECT * FROM hyperskill.users_is_biased)

)

SELECT *
FROM result;","1. Describe the expected query result: The query will return a distinct list of user IDs who have clicked on either 'ide' or 'install_ide' within the last month, excluding those who are listed in the 'users_is_biased' table.

2. Break down the query into logical parts: The query consists of two main parts - a Common Table Expression (CTE) named 'result' and the main SELECT statement.

3. Part descriptions:

- Common Table Expression (CTE) 'result':
  a. Select the distinct 'user_id' from the 'hyperskill.content' table.
  b. Filter the records where the 'date' is within the last month from the current date.
  c. Include only those records where the 'action' column is equal to 'click'.
  d. Further filter the records to include only those where the 'target' column is either 'ide' or 'install_ide'.
  e. Exclude any 'user_id' that exists in the 'hyperskill.users_is_biased' table.

- Main SELECT statement:
  a. Retrieve all records from the CTE 'result'.","Can you provide me with a list of unique users who have clicked on 'ide' or 'install_ide' in the past month, but make sure to exclude any users who might have biased interactions according to our internal records?"
"-- https://vyahhi.myjetbrains.com/youtrack/issue/AN-1951/Unload-the-users-who-clicked-on-the-payment-transition

-- Users who clicked on the buttons to go to Checkout
-- We need the country for each user
-- Period: October 11 - October 18

WITH

'2023-10-11' AS start_date,
'2023-10-18' AS end_date,

clicked_on_the_payment_transition AS (

    SELECT
        user_id
    FROM hyperskill.content
    WHERE
        date BETWEEN start_date AND end_date
        AND action = 'click'
        AND page_part = 'subscription_plan'
        AND target IN ('start_premium', 'start_subscription', 'start_your_subscription')
        AND frontend_context = '{""provider"": ""stripe""}'

)

SELECT
    verified_primary_email AS email,
    coalesce(country, first_country) AS country
FROM hyperskill_private.registered_users
WHERE
    is_biased = 0
    AND is_superuser = 0
    AND user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased)
    AND user_id IN (SELECT user_id FROM clicked_on_the_payment_transition)
    AND email NOT LIKE '%\+%'
    AND email != '';","The expected result of the query is a list of emails and countries of users who clicked on the payment transition buttons to go to Checkout on the Hyperskill platform during the period from October 11 to October 18, 2023.

The query is broken down into the following logical parts:

1. Date Range Definition: Define the start and end dates for the period of interest.
2. Clicked Payment Transition Subquery: Create a subquery to select user IDs from the 'hyperskill.content' table where the 'date' is between the defined start and end dates, the 'action' is a 'click', the 'page_part' is 'subscription_plan', the 'target' is one of 'start_premium', 'start_subscription', or 'start_your_subscription', and the 'frontend_context' is a JSON object with a 'provider' key set to 'stripe'.
3. Main Query: Select the 'verified_primary_email' and 'country' from the 'hyperskill_private.registered_users' table where the user is not biased, not a superuser, not in the list of biased users from 'hyperskill.users_is_biased', clicked on the payment transition as identified by the subquery, the email does not contain a '+' character, and the email is not an empty string. Use COALESCE to ensure that if 'country' is NULL, 'first_country' is used instead.","Can you provide me with a list of emails and countries for users who clicked on our payment transition buttons leading to Checkout on Hyperskill between October 11th and 18th? We're particularly interested in those who used Stripe as their payment provider. Please exclude any biased users, superusers, or those with non-standard email addresses."
"SELECT
    email,
    date_registered
FROM hyperskill_private.users
WHERE
    is_biased = 0
    AND is_superuser = 0
    AND id NOT IN (SELECT user_id FROM hyperskill.users_is_biased)
    AND country NOT IN ('Russia', 'Belarus')
    AND
        (sub_org_str_map != '{}'
             OR sub_org_member_str_map != '{}'
             OR sub_org_trial_str_map != '{}')","The query is designed to retrieve a list of users with specific criteria. The expected result is a set of records containing the users' email addresses and their registration dates.

1. Selection Criteria: The query will filter users based on several conditions using the columns 'is_biased', 'is_superuser', 'id', and 'country'.

2. Subquery Exclusion: A subquery will be used to exclude users whose 'id' appears in the 'user_id' column of the 'hyperskill.users_is_biased' table.

3. Country Exclusion: Users from certain countries ('Russia', 'Belarus') will be excluded by checking the 'country' column.

4. JSON Data Check: The query will include users who have non-empty JSON data in at least one of the columns 'sub_org_str_map', 'sub_org_member_str_map', or 'sub_org_trial_str_map'.

Each part of the query contributes to narrowing down the list of users to those who meet all the specified conditions.","Can you provide me with a list of users who are not biased, not superusers, and not from Russia or Belarus? Also, make sure they have some data in their organization-related fields. I need their email addresses and registration dates."
"-- https://vyahhi.myjetbrains.com/youtrack/issue/AN-1927/Dashboard-to-track-Mobile-Premium-DLU


-- Modify the view hyperskill_reports.learning_users: added platform, added new user type – Premium (100% discount)

CREATE OR REPLACE VIEW hyperskill_reports.learning_users
AS

WITH

first_purchase_dates AS (

    SELECT
        hyperskill_user_id AS user_id,
        min(transaction_dt) AS first_paid_transaction_dt
    FROM hyperskill_reports.sales
    WHERE
        amount_usd_cents > 0
        AND product_type IN ('personal', 'premium')
        AND hyperskill_user_id > 0
    GROUP BY
        user_id

),

user_subscriptions AS (

    SELECT

        user_id,
        groupArray(
            (
             -- change subscription start date to actual first payment date
             -- for users who had 100% discount for the first month and then bought subscription
             if(first_paid_transaction_dt > created_at
                    AND first_paid_transaction_dt < valid_till
                    AND date_diff(day, created_at, first_paid_transaction_dt) < 35,
                 first_paid_transaction_dt, created_at),
             valid_till)
        ) AS subscription_dates

    FROM hyperskill_private.stg_subscriptions

    LEFT JOIN first_purchase_dates USING user_id

    WHERE
        type IN ('premium', 'personal')
        AND user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased)
        AND user_id IN (
            SELECT user_id
            FROM first_purchase_dates
        )
        AND is_enabled = 1
        AND deleted_at IS NULL
        AND users_count > 0

    GROUP BY
        user_id

),

user_activity AS (

    SELECT DISTINCT
        date,
        user_id,
        toDate(if(registration_date < '2001-01-01',
                 dictGetDateTime('hyperskill_private.users_dict', 'date_registered', toUInt64(user_id)),
                 registration_date)) AS registration_date,
        toStartOfWeek(registration_date) AS week_cohort,
        toStartOfMonth(registration_date) AS month_cohort,
        -- Last subscription type on date
        argMax(
            multiIf(
                subscription_type = 'personal', 'Personal',
                subscription_type IN ('team member', 'commercial'), 'Team Member',
                subscription_type = 'freemium', 'Freemium',
                subscription_type = 'premium', 'Premium',
                'Other'
            ) AS tmp_user_type,
            dt) OVER(PARTITION BY (user_id, date)) AS user_type,
        if((dictGetString('hyperskill_reports.dlu_segments_dict', 'first_click_channel', toUInt64(user_id)) AS channel) =
              '', 'Other', channel) AS first_click_channel,
        platform
    FROM hyperskill.content
    WHERE
        date >= today() - 28 * 7
        AND date <= today() - 1
        AND user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased)
        AND action IN ('failed_submission', 'completed_submission', 'rejected_submission')
        AND step_type != 'text'

),

learning_users AS (

    SELECT
        date,
        user_id,
        registration_date,
        week_cohort,
        month_cohort,
        first_click_channel,
        platform,
        subscription_dates,
        arrayExists(x -> (date BETWEEN toDate(assumeNotNull(x.1)) AND toDate(assumeNotNull(x.2))),
            subscription_dates) AS is_paid_period,
        if(user_type = 'Premium' AND is_paid_period = 0, 'Premium (100% discount)', user_type) AS user_type
    FROM user_activity
    LEFT JOIN user_subscriptions USING user_id

)

SELECT
    date,
    user_id,
    registration_date,
    week_cohort,
    month_cohort,
    user_type,
    first_click_channel,
    platform
FROM learning_users;","1. Describe the expected query result:
- The query will create or replace a view named 'hyperskill_reports.learning_users'.
- The view will contain columns for date, user_id, registration_date, week_cohort, month_cohort, user_type, first_click_channel, and platform.
- The view will represent data about learning users, their subscription status, and platform usage.

2. Break down the query into logical parts:
- Part A: first_purchase_dates
- Part B: user_subscriptions
- Part C: user_activity
- Part D: learning_users
- Part E: Final SELECT statement to create the view

3. Description of each part without code:

Part A: first_purchase_dates
- Select the minimum transaction date as the first paid transaction date for each user from the sales table.
- Filter for transactions with a positive amount in USD cents and product types 'personal' or 'premium'.
- Exclude users with an ID less than or equal to zero.
- Group the results by user ID.

Part B: user_subscriptions
- Select user IDs and an array of subscription start and end dates.
- Adjust the subscription start date to the actual first payment date for users who had a 100% discount for the first month and then bought a subscription.
- Join with the first_purchase_dates to get the first paid transaction date.
- Filter for enabled subscriptions of types 'premium' or 'personal' that are not deleted and have a user count greater than zero.
- Exclude biased user IDs.
- Group the results by user ID.

Part C: user_activity
- Select distinct records of user activity including date, user ID, registration date, week cohort, month cohort, last subscription type on date, first click channel, and platform.
- Filter for activity within the last 28 weeks up to yesterday.
- Exclude biased user IDs and text step types.
- Include actions related to submissions.

Part D: learning_users
- Combine user activity with subscription data.
- Determine if the date falls within any of the user's paid subscription periods.
- Adjust the user type to 'Premium (100% discount)' for users with a 'Premium' type who are not in a paid period.

Part E: Final SELECT statement to create the view
- Select the necessary columns from the learning_users part to form the final view.","Can you provide a report view that shows the activity and subscription details of our learning users, including their first payment date, subscription status, and the platform they use? We're particularly interested in data from the last 28 weeks."
"
-- https://vyahhi.myjetbrains.com/youtrack/issue/AN-1941/Explore-Try-out-projects-for-free-banner

-- I need a table with data to analyze where users are dropping off.
-- How many users
-- * see it
-- * click on it
-- * choose project
-- * complete stage

-- Banner https://hyperskill.org/admin/banners/banner/73/change/
-- Feature https://hyperskill.org/admin/feature_switcher/feature/267/change/


-- ======== TECH RESEARCH ========
-- shown
-- {""action"":""shown"",""route"":""/study-plan"",""part"":""main"",
-- ""target"":""banner"",""context"":{""banner_id"":73},
-- ""user"":527643758,""client_time"":""2023-10-17T10:22:03.446Z"",""screen_size"":1800}
-- +-------------------+---------+------+-----------+---------+------+-----------------+
-- |dt                 |user_id  |action|page       |page_part|target|frontend_context |
-- +-------------------+---------+------+-----------+---------+------+-----------------+
-- |2023-10-17 10:22:08|527643758|shown |/study-plan|main     |banner|{""banner_id"": 73}|
-- +-------------------+---------+------+-----------+---------+------+-----------------+

select
    min(date), -- 2023-08-24
    count(), -- 132365
    uniqExact(user_id) AS users  -- 8560
from hyperskill.content
where
    action = 'shown' and
    page like '/study-plan%' and
    target = 'banner' and
    subscription_type = 'freemium' and
    JSONExtractInt(frontend_context, 'banner_id') = 73;


-- click
--{""action"":""click"",""user"":527643758,""route"":""/study-plan"",""part"":""first_stage_banner"",
-- ""target"":""primary_action"",""context"":null,""client_time"":""2023-10-17T10:23:51.492Z"",""screen_size"":1800}
-- +-------------------+---------+------+-----------+------------------+-------------+----------------+
-- |dt                 |user_id  |action|page       |page_part         |target       |frontend_context|
-- +-------------------+---------+------+-----------+------------------+-------------+----------------+
-- |2023-10-17 10:23:21|527643758|click |/study-plan|first_stage_banner|find_out_more|null            |
-- +-------------------+---------+------+-----------+------------------+-------------+----------------+
-- or
-- {""action"":""click"",""user"":527643758,""route"":""/study-plan"",""part"":""first_stage_banner"",
-- ""target"":""find_out_more"",""context"":null,""client_time"":""2023-10-17T10:25:01.630Z"",""screen_size"":1800}
-- +------+-----------+------------------+--------------+----------------+
-- |action|page       |page_part         |target        |frontend_context|
-- +------+-----------+------------------+--------------+----------------+
-- |click |/study-plan|first_stage_banner|primary_action|null            |
-- +------+-----------+------------------+--------------+----------------+

select
    count(), -- 3253
    uniqExact(user_id), -- 2056
    uniqExactIf(user_id, target = 'primary_action'), -- 1707
    uniqExactIf(user_id, target = 'find_out_more'),  -- 579
    uniqExactIf(user_id, target IN ('primary_action', 'find_out_more'))  -- 2056
from hyperskill.content
where
    date >= '2023-08-24' and
    action = 'click' and
    page like '/study-plan%' and
    subscription_type = 'freemium' and
    page_part = 'first_stage_banner';

-- choose project
-- selected_project is not logged
-- +-------------------+---------+------+---------------------+---------+--------------+----------------+
-- |dt                 |user_id  |action|page                 |page_part|target        |frontend_context|
-- +-------------------+---------+------+---------------------+---------+--------------+----------------+
-- |2023-10-17 10:27:50|527643758|click |/projects/343?track=2|main     |select_project|null            |
-- +-------------------+---------+------+---------------------+---------+--------------+----------------+
-- viewed stage after selecting project
-- +-------------------+---------+------+-----------------------------------+---------+------+----------------+
-- |dt                 |user_id  |action|page                               |page_part|target|frontend_context|
-- +-------------------+---------+------+-----------------------------------+---------+------+----------------+
-- |2023-10-17 10:27:50|527643758|view  |/projects/343/stages/2017/implement|         |      |null            |
-- +-------------------+---------+------+-----------------------------------+---------+------+----------------+
-- or
-- +-------------------+---------+-----------+----+---------+------+----------------+-------------------+----------+--------+------------+
-- |dt                 |user_id  |action     |page|page_part|target|frontend_context|selected_project_id|project_id|stage_id|stage_number|
-- +-------------------+---------+-----------+----+---------+------+----------------+-------------------+----------+--------+------------+
-- |2023-10-17 10:27:45|527643758|viewed_step|    |         |      |{}              |0                  |343       |2017    |1           |
-- +-------------------+---------+-----------+----+---------+------+----------------+-------------------+----------+--------+------------+

select
    count(), -- 7376
    uniqExact(user_id) -- 2866. пользователей больше, чем тех, кто просто кликнул,
from hyperskill.content
where
    date >= '2023-08-24' and
    subscription_type = 'freemium' and
    action = 'viewed_step' and
    project_id > 0 and
    stage_id > 0 and
    stage_number = 1

;

-- complete stage
-- +-------------------+---------+---------------+----+---------+------+----------------+-------------------+----------+--------+------------+
-- |dt                 |user_id  |action         |page|page_part|target|frontend_context|selected_project_id|project_id|stage_id|stage_number|
-- +-------------------+---------+---------------+----+---------+------+----------------+-------------------+----------+--------+------------+
-- |2023-10-17 10:29:08|527643758|completed_stage|    |         |      |{}              |0                  |343       |2017    |1           |
-- +-------------------+---------+---------------+----+---------+------+----------------+-------------------+----------+--------+------------+
select
    count(), -- 1110
    uniqExact(user_id), -- 1004
    uniqExactIf(user_id, platform != 'ide'),  -- 835
    uniqExactIf(user_id, platform = 'ide')  -- 176
from hyperskill.content
where
    date >= '2023-08-24' and
    subscription_type = 'freemium' and
    action = 'completed_stage' and
    project_id > 0 and
    stage_id > 0 and
    stage_number = 1;


-- modal shown
-- +-------------------+---------+-----------+-----------------------------------+---------------------------+------+
-- |dt                 |user_id  |action     |page                               |page_part                  |target|
-- +-------------------+---------+-----------+-----------------------------------+---------------------------+------+
-- |2023-10-17 10:29:15|527643758|modal_shown|/projects/343/stages/2017/implement|completed_first_stage_modal|modal |
-- +-------------------+---------+-----------+-----------------------------------+---------------------------+------+
select
    count(), -- 1004
    uniqExact(user_id) --933
from hyperskill.content
where
    date >= '2023-08-24' and
    subscription_type = 'freemium' and
    action = 'modal_shown' and
    page_part = 'completed_first_stage_modal' and
    target = 'modal';

-- modal click
--{""action"":""modal_hide"",""route"":""/projects/343/stages/2017/implement"",""part"":""completed_first_stage_modal"",""target"":""ok"",
-- ""user"":527643758,""client_time"":""2023-10-17T10:29:37.366Z"",""screen_size"":1800},
-- +-------------------+---------+----------+-----------------------------------+---------------------------+------+----------------+
-- |dt                 |user_id  |action    |page                               |page_part                  |target|frontend_context|
-- +-------------------+---------+----------+-----------------------------------+---------------------------+------+----------------+
-- |2023-10-17 10:29:52|527643758|modal_hide|/projects/343/stages/2017/implement|completed_first_stage_modal|ok    |null            |
-- +-------------------+---------+----------+-----------------------------------+---------------------------+------+----------------+
-- or
-- {""action"":""click"",""user"":527643758,""route"":""/projects/343/stages/2017/implement"",""part"":""completed_first_stage_modal"",
-- ""target"":""copy code and get premium"",""client_time"":""2023-10-17T10:29:37.390Z"",""screen_size"":1800},
-- +-------------------+---------+------+-----------------------------------+---------------------------+-------------------------+----------------+
-- |dt                 |user_id  |action|page                               |page_part                  |target                   |frontend_context|
-- +-------------------+---------+------+-----------------------------------+---------------------------+-------------------------+----------------+
-- |2023-10-17 10:29:52|527643758|click |/projects/343/stages/2017/implement|completed_first_stage_modal|copy code and get premium|null            |
-- |2023-10-17 10:29:52|527643758|click |/projects/343/stages/2017/implement|description                |continue                 |null            |
-- +-------------------+---------+------+-----------------------------------+---------------------------+-------------------------+----------------+

select
    distinct
    subscription_type,
    action,
    target
from hyperskill.content
where
    date >= '2023-08-24' and
    page_part = 'completed_first_stage_modal'
order by
    subscription_type,
    action,
    target;

select
    count(), -- 1084
    uniqExact(user_id), -- 919
    uniqExactIf(user_id, target = 'copy code and get premium'), -- 50
    uniqExactIf(user_id, target = 'ok'), -- 139
    uniqExactIf(user_id, target IN ('ok', 'copy code and get premium')),  -- 139
    uniqExactIf(user_id, target = 'get premium'), -- 80
    uniqExactIf(user_id, target IN ('copy code and get premium', 'get premium')) -- 130
from hyperskill.content
where
    date >= '2023-08-24' and
    subscription_type = 'freemium' and
    action in ('modal_hide', 'click') and
    page_part = 'completed_first_stage_modal';
-- оставить только клики по кнопкам, ведущим на страницу покупки

-- купили с промокодом powerup - таких данных нет -- IbulW6vX
select
    uniqExact(user_id),
    JSON_VALUE(data, '$.discount.coupon.name') as coupon_name,
    JSON_VALUE(data, '$.discount.coupon.id') as coupon_id
    --JSONExtractString(subscription_data, 'discount') as coupon
from hyperskill_mariadb.subscriptions_subscription
where
    type = 'premium' and user_id = 527643758
group by
    coupon_name, coupon_id;



--
-- ======== RESULT QUERY ========

CREATE OR REPLACE VIEW hyperskill_reports.banners__banner_73_first_stage__events

AS

WITH

viewed_banner AS (

    SELECT
        user_id
    FROM hyperskill.content
    WHERE
        date >= '2023-08-24'
        AND subscription_type = 'freemium'
        AND action = 'shown'
        AND page LIKE '/study-plan%'
        AND target = 'banner'
        AND JSONExtractInt(frontend_context, 'banner_id') = 73

),

events AS (

    SELECT
        DISTINCT
        dt,
        user_id,
        action,
        page,
        target,
        page_part,
        multiIf(
            action = 'shown'
                AND target = 'banner', '01 Banner Shown',
            action = 'click'
                AND page_part = 'first_stage_banner', '02 Clicked On Banner',
            action = 'viewed_step', '03 Viewed The First Stage',
            action IN ('failed_submission', 'completed_submission')
                AND stage_number = 1, '04 Tried The First Stage',
            action = 'completed_stage'
                AND stage_number = 1, '05 Completed The First Stage',
            action = 'modal_shown'
                AND page_part = 'completed_first_stage_modal', '06 Viewed Modal After Stage Completion',
            action = 'click'
                AND page_part = 'completed_first_stage_modal'
                AND target IN ('copy code and get premium', 'get premium'), '07 Clicked On Modal Get Premium',
            '00 Bug'
        ) AS event,
        dictGetDateTime('hyperskill.subscribers_dict',
            'first_subscribtion_created_at', (toUInt64(user_id), 'premium')) AS first_premium_subscription_created_at
    FROM hyperskill.content
    WHERE
        date >= '2023-08-24'
        AND subscription_type = 'freemium'
        AND user_id IN viewed_banner
        AND (
            (
                -- banner views
                action = 'shown'
                AND page LIKE '/study-plan%'
                AND target = 'banner'
                AND JSONExtractInt(frontend_context, 'banner_id') = 73
            )
            OR
            (
                -- banner clicks
                action = 'click'
                AND page LIKE '/study-plan%'
                AND page_part = 'first_stage_banner'
            )
            OR
            (
                -- selected project – viewed the stage
                action = 'viewed_step'
                AND project_id > 0
                AND stage_id > 0
                AND stage_number = 1
            )
            OR
            (
                -- tried stage
                action IN ('failed_submission', 'completed_submission')
                AND project_id > 0
                AND stage_id > 0
                AND stage_number = 1
            )
            OR
            (
                -- completed stage
                action = 'completed_stage'
                AND project_id > 0
                AND stage_id > 0
                AND stage_number = 1
            )
            OR
            (
                -- viewed modal after stage completion
                action = 'modal_shown'
                AND page_part = 'completed_first_stage_modal'
                AND target = 'modal'
            )
            OR
            (
                -- clicked on button ""Start subscription""
                action = 'click'
                AND page_part = 'completed_first_stage_modal'
                AND target IN ('copy code and get premium', 'get premium')
            )
        )

    ORDER BY
        user_id,
        date

)

SELECT
    *
FROM events;
","Describe the expected query result:
- The query is designed to create a view that will contain a series of events related to user interactions with a specific banner (banner_id 73) on the Hyperskill platform. The view will track user actions from seeing the banner to potentially starting a premium subscription.

2. Break down the query into logical parts:
- Part A: Subquery to identify users who have viewed the banner.
- Part B: Main query to collect distinct events for users who viewed the banner.

3. Write a short description for each part using column names:

Part A: Subquery (viewed_banner)
- Select the user_id from the 'hyperskill.content' table.
- Filter records where the action is 'shown', the page is like '/study-plan%', the target is 'banner', the subscription_type is 'freemium', and the banner_id is 73 extracted from the frontend_context JSON field.

Part B: Main query (events)
- Select distinct records with columns dt, user_id, action, page, target, page_part.
- Use a multiIf function to categorize events based on action, target, and page_part.
- Include events such as banner shown, clicked on banner, viewed the first stage, tried the first stage, completed the first stage, viewed modal after stage completion, and clicked on modal get premium.
- Join the subquery on user_id to filter events for users who have seen the banner.
- Order the results by user_id and date.

- Finally, select all records from the events subquery to be included in the view 'hyperskill_reports.banners__banner_73_first_stage__events'.","Can we get a report on how users are interacting with banner 73 on the Hyperskill platform? Specifically, I'm interested in tracking their journey from seeing the banner to starting a premium subscription, including any clicks and actions on the first stage after seeing the banner."
"-- Reached daily limit in registration day, %, after first track selection.
WITH
today() - 28 * 4 AS start_from_period,
user_first_track_selection AS (
    SELECT
        user_id,
        dictGetDateTime('hyperskill.alt_users_stepikuser_dict', 'date_registered',
                        toUInt64(user_id))                             AS registration_date,
        minIf(dt, action = 'selected_track')                           AS first_track_selection_dt,
        argMinIf(selected_track_id, dt, action = 'selected_track')     AS first_track_selection_id,
        date_diff('hour', first_track_selection_dt, registration_date) AS diff_hours
    FROM hyperskill.content
    WHERE
        date >= start_from_period
        AND registration_date >= start_from_period
        AND action IN ('selected_track')
    GROUP BY user_id, registration_date
             -- drop users who selected track more than 2 hours after or before registration
             -- suspicious users
    HAVING diff_hours BETWEEN -2 AND 2
)
SELECT
    user_id,
    registration_date,
    first_track_selection_dt,
    first_track_selection_id AS track_id,
    dictGetStringOrDefault(
            'hyperskill.tracks_track_dict', 'title', toUInt64(selected_track_id),
            'Track is not exist. Please, call an analyst.'
    ) AS track_title,
    if(
        uniqExactIf(dt, action = 'reached_limit'
            -- if user reached limit in first 24 hours after track selection
            AND dt BETWEEN first_track_selection_dt
                AND first_track_selection_dt + interval 1 day
        ) > 0, 1, 0
    ) AS day_0_limit_reached,
    if(
        uniqExactIf(dt, action = 'completed_step'
            -- if user completed step on next day after track selection
            AND date = toDate(first_track_selection_dt) + interval 1 day
        ) > 0, 1, 0
    ) AS day_1_retained
FROM hyperskill.content
LEFT JOIN user_first_track_selection USING (user_id)
WHERE
    date >= start_from_period - 1
    AND registration_date >= start_from_period
    AND action IN ('registered_user', 'selected_track',
                 'reached_limit', 'completed_step')
GROUP BY
    user_id,
    registration_date,
    first_track_selection_dt,
    track_id,
    selected_track_id
HAVING first_track_selection_dt >= '2021-01-01';


-- First Day Retention - retention in theory or task completion on the next day after registration, after first track selection.
WITH
today() - 28 * 4 AS start_from_period,
user_first_track_selection AS (
    SELECT
        user_id,
        dictGetDateTime('hyperskill.alt_users_stepikuser_dict', 'date_registered',
                        toUInt64(user_id)
        ) AS registration_date,
        minIf(dt, action = 'selected_track') AS first_track_selection_dt,
        argMinIf(selected_track_id, dt, action = 'selected_track') AS first_track_selection_id,
        date_diff('hour', first_track_selection_dt, registration_date) AS diff_hours
    FROM hyperskill.content
    WHERE
        date >= start_from_period
        AND registration_date >= start_from_period
        AND action IN ('selected_track')
    GROUP BY user_id, registration_date
             -- drop users who selected track more than 2 hours after or before registration
             -- suspicious users
    HAVING diff_hours BETWEEN -2 AND 2
)
SELECT
    user_id,
    registration_date,
    first_track_selection_dt,
    first_track_selection_id AS track_id,
    dictGetStringOrDefault(
            'hyperskill.tracks_track_dict', 'title', toUInt64(selected_track_id),
            'Track is not exist. Please, call an analyst.'
    ) AS track_title,
    if(
        uniqExactIf(dt, action = 'reached_limit'
        -- if user reached limit in first 24 hours after track selection
            AND dt BETWEEN first_track_selection_dt
                AND first_track_selection_dt + interval 1 day
        ) > 0, 1, 0
    ) AS day_0_limit_reached,
    if(
        uniqExactIf(dt, action = 'completed_step'
        -- if user completed step on next day after track selection
        AND date = toDate(first_track_selection_dt) + interval 1 day
        ) > 0, 1, 0
    ) AS day_1_retained
FROM hyperskill.content
LEFT JOIN user_first_track_selection USING (user_id)
WHERE
    date >= start_from_period - 1
    AND registration_date >= start_from_period
    AND action IN ('registered_user', 'selected_track',
                   'reached_limit', 'completed_step')
GROUP BY
    user_id,
    registration_date,
    first_track_selection_dt,
    track_id,
    selected_track_id
HAVING first_track_selection_dt >= '2021-01-01'","1. Define the expected result of the query: The query is expected to return a list of users who have selected their first track within a specific time frame, along with the date of registration, the date of first track selection, the track ID, the track title, and indicators for whether they reached the daily limit on the day of track selection and whether they completed a step on the next day after track selection.

2. Break down the query into logical parts:
   - Calculation of the start date for the period of interest.
   - Subquery to identify the first track selection for each user.
   - Main query to retrieve user details and calculate indicators for daily limit reached and next day retention.

3. Description of each part without code:
   - Calculate the start date by subtracting 112 days (28 days multiplied by 4) from the current date to define the period of interest for the analysis.
   - Create a subquery (user_first_track_selection) that selects users based on the following criteria:
     - The user's action must be 'selected_track'.
     - The user's registration date and the date of the action must be within the period of interest.
     - Group the results by user_id and registration_date.
     - For each user, determine the earliest date and time (first_track_selection_dt) they selected a track and the corresponding track ID (first_track_selection_id).
     - Calculate the difference in hours between the first track selection and the registration date (diff_hours).
     - Filter out users whose first track selection occurred more than 2 hours before or after their registration date.
   - In the main query:
     - Join the subquery results with the hyperskill.content table using the user_id.
     - Filter actions to include 'registered_user', 'selected_track', 'reached_limit', and 'completed_step', and ensure the dates are within the adjusted period of interest.
     - Group the results by user_id, registration_date, first_track_selection_dt, track_id, and selected_track_id.
     - Retrieve the track title using a dictionary lookup with a default message if the track does not exist.
     - Calculate two indicators:
       - day_0_limit_reached: Whether the user reached the daily limit within 24 hours after track selection.
       - day_1_retained: Whether the user completed a step on the next day after track selection.
     - Filter the final results to include only track selections that occurred on or after January 1, 2021.","Can you provide me with a list of users who started their first track within the last four weeks? I need to see their registration date, the date they picked their first track, the track ID and title, and also if they hit the daily limit on the same day and if they completed a step the following day. Please only include those who selected their first track after January 1, 2021."
"WITH
today() AS some_date,
step_publication_dt AS (
    SELECT
        step_id,
        first_publication_dt,
        step_type

    FROM hyperskill_reports.steps__first_publication_dt

    WHERE is_stage = 0
      AND step_type <> 'text'
),

enabled_alpha_auto_steps AS (
    SELECT
        step_id

    FROM hyperskill.stg_steps

    WHERE
        is_enabled = 1
        AND deleted_at is NULL
        AND readiness IN ('alpha_auto')
        AND status = 1
),

('completed_step', 'failed_submission', 'completed_submission',
'created_like', 'skipped_step', 'viewed_step') AS events_filter,

step_user_stat AS (
    SELECT 
        user_id,
        step_id,
        topic_id,
        minIf(dt,
              action IN ('completed_step', 'failed_submission', 'completed_submission')
        ) AS dt,
        retention(action IN events_filter,
                  action IN ('completed_step', 'failed_submission', 'completed_submission'),
                  action IN ('completed_step', 'completed_submission'),
                  action = 'skipped_step',
                  action = 'created_like' AND like_type != 'skip'
        ) AS actions,
        actions[1]                                                                       AS is_viewed,
        actions[2]                                                                       AS is_tried,
        actions[3]                                                                       AS is_completed,
        actions[4]                                                                       AS is_skipped,
        actions[5]                                                                       AS is_liked,
        countIf(action, action = 'completed_submission')                                 AS completed_submissions,
        countIf(action, action = 'failed_submission')                                    AS failed_submissions,
        anyIf(like_value, action = 'created_like' AND like_type != 'skip')               AS rating,
        anyIf(
            multiIf(
                          like_value = 100, 'hard',
                          like_value = 101, 'easy',
                          like_value = 102, 'boring',
                          ''
            ), action = 'created_like' AND like_type = 'skip'
        )                     AS skip_reason

    FROM hyperskill.content

    WHERE 
        action IN events_filter
        AND (step_id > 0)
        AND (solving_context IN ('', 'default'))
        AND (step_type != 'text')
        AND (is_stage = 0)
        AND step_id IN (SELECT step_id FROM enabled_alpha_auto_steps)
        AND (date >= (some_date - interval 6 month))
        AND (user_id NOT IN (SELECT user_id
                           FROM hyperskill.users_is_biased)
            )

    GROUP BY step_id, user_id, topic_id
),
step_stats AS (
    SELECT 
        step_id,
        topic_id,
        first_publication_dt,
        uniqExact(user_id)                                                       AS viewed_users,
        uniqExactIf(user_id, is_tried)                                           AS tried_users,
        uniqExactIf(user_id, is_tried AND is_completed)                          AS completed_users,

        uniqExactIf(user_id, is_tried AND is_skipped)                            AS tried_and_skipped_users,
        uniqExactIf(user_id, is_tried AND is_skipped AND skip_reason = 'hard')   AS hard_skipped_users,
        uniqExactIf(user_id, is_tried AND is_skipped AND skip_reason = 'boring') AS boring_skipped_users,
        uniqExactIf(user_id, is_tried AND is_skipped AND skip_reason = 'easy')   AS easy_skipped_users,
        tried_and_skipped_users / tried_users                                    AS skip_rate,
        hard_skipped_users / tried_and_skipped_users                             AS hard_skip_rate,

        uniqExactIf(user_id, is_liked)                                           AS liked_users,
        avgIf(rating, is_liked)                                                  AS avg_like,
        countIf(rating, is_liked AND rating IN (-2, -1, 0))                      AS non_positive_like_count,

        sum(completed_submissions)                                               AS completed_subs_count,
        sum(failed_submissions)                                                  AS failed_subs_count,

        tried_users / viewed_users                                               AS tried_rate,
        completed_users / tried_users                                            AS completion_rate,
        completed_subs_count / (completed_subs_count + failed_subs_count)        AS success_rate,

        if(completed_users >= 50 AND liked_users >= 4, 1, 0)                     AS is_reached_enough_users,
        if( -- users tried to solve problem
                        tried_rate > 0.93
                    -- users didn't skip to often, skip for hard reason
                    AND (skip_rate <= 0.1)
                    -- users tried to solve problem and completed it
                    -- (users can complete less, but avg like should be more in such case)
                    AND (completion_rate >= 0.93 OR (completion_rate >= 0.88 AND avg_like > 1.6))
                    -- problem isn't so easy or so hard by submissions
                    AND success_rate BETWEEN 0.1 AND 0.9
                    -- users liked problem
                    AND avg_like > 1.2,
                        1, 0
        )                                                    AS is_good_quality
    FROM step_user_stat
    LEFT JOIN step_publication_dt USING step_id
    WHERE dt > first_publication_dt
    GROUP BY 
        step_id, 
        topic_id, 
        first_publication_dt
)
SELECT *
FROM step_stats
WHERE is_reached_enough_users = 1
  AND is_good_quality = 1;","1. The query result to be expected:
The query is divided into two parts: one for the theory tab and one for the practice tab. For each tab, it returns the average click rate for different elements (such as comments, hints, user links, show discussion, solutions, see hint) over the past six months.

2. Break down the query into logical parts:
- Part 1: Calculate statistics for the theory tab
- Part 2: Calculate statistics for the practice tab

3. Description for each part:

Part 1: Calculate statistics for the theory tab
- Create a subquery ""theories"" to select step_id and topic_id from the stg_steps table where step_type is 'text'.
- Create a subquery ""actions_stat_on_theory"" to calculate the number of unique users who visited, clicked on comments, clicked on useful links, and clicked on show discussion from the content table where the action is 'click' and the step_id is in the ""theories"" subquery. Also, calculate the click rate for each of these actions.
- Create a subquery ""objects_stat_on_theory"" to calculate the average click rate for comments, useful links, and show discussion.
- Finally, select all records from the ""objects_stat_on_theory"" subquery.

Part 2: Calculate statistics for the practice tab
- Create a subquery ""problems"" to select step_id and topic_id from the stg_steps table where step_type is not 'text' and topic_id is greater than 0.
- Create a subquery ""actions_stat_on_problems"" to calculate the number of unique users who visited, clicked on comments, clicked on useful links, clicked on show discussion, clicked on solutions, clicked on hints, and clicked on see hint from the content table where the action is 'click' and the step_id is in the ""problems"" subquery. Also, calculate the click rate for each of these actions.
- Create a subquery ""objects_stat_on_problems"" to calculate the average click rate for comments, useful links, show discussion, solutions, hints, and see hint.
- Finally, select all records from the ""objects_stat_on_problems"" subquery.","Can we get a report on how users have been interacting with different elements on our platform? Specifically, I'd like to see the average click rates for comments, hints, and other interactive features on both the theory and practice sections over the last six months."
"WITH

map(
    '1', 'I have never studied it before',
    '2', 'I have studied it online, but I do not use it professionally',
    '3', 'I study it as part of a school/college/university program',
    '4', 'I have studied it before, and I use it professionally',
    '', 'No Data'
) AS talg_question_1_dict,

map(
    '1', 'I want to apply for my first job that requires skills in what I want to learn',
    '2', 'I want to get better at my current job that requires skills in what I want to learn',
    '3', 'I use a different language/technology and want to change the technology stack',
    '4', 'I want to get better at my job that does not require skills in what I want to learn',
    '5', 'I just find the topic interesting and want to learn it for myself',
    '6', 'I want to see if what I want to learn is right for me',
    '-1', 'Other',
    '', 'No Data'
) AS talg_question_2_dict
SELECT
    dictGetStringOrDefault(
            'hyperskill.tracks_track_dict', 'title', toUInt64(selected_track_id),
            'Track is not exist. Please, call an analyst.'
    )                                      AS track_title,
    talg_question_1_dict[polls.question_1] AS experience,
    talg_question_2_dict[polls.question_2] AS motivation,
    uniqExact(user_id)                     AS answered_users
FROM hyperskill.polls
WHERE poll_id = 4
GROUP BY track_title, experience, motivation
ORDER BY track_title, experience, motivation DESC;","1. The expected result of the query is a list of tracks with the titles, user experience levels, user motivations for learning, and the count of unique users who answered the poll.

2. The logical parts of the query are:
   - Common Table Expressions (CTEs) for mapping poll answers to descriptive text
   - Selection of data from the polls table
   - Aggregation of data to count unique users
   - Ordering of the result set

3. Part descriptions:
   - Define two CTEs, one for mapping question 1 answers to experience levels and another for mapping question 2 answers to motivations.
   - Select the track title by converting the selected_track_id to a string using a dictionary lookup, and if the track does not exist, return a default message.
   - Use the CTEs to translate the numeric answers from polls.question_1 and polls.question_2 into descriptive text for experience and motivation.
   - Count the unique user_id values for each combination of track title, experience, and motivation.
   - Filter the results to include only entries from poll_id 4.
   - Group the results by track title, experience, and motivation.
   - Order the final result set by track title, and then by experience and motivation in descending order.","Can we get a breakdown of the number of unique users by track title, their experience level, and motivation for learning from the latest poll? We're interested in understanding user demographics and preferences for our learning tracks."
" -- int_users__first_diagnostics_activity_conversions.sql

WITH

user_diagnostics_dts AS (

    SELECT
        user_id,
        -- TODO: ALT-8702 Add new event `started_diagnostics` in events_event,
        --  hyperskill.content first track_id where user selected diagnostics
        --  on study plan or started diagnostics (viewed diagnostics step)
        argMinIf(
            selected_track_id, dt,
            (
                action = 'click'
                AND page LIKE '%/study-plan%'
                AND frontend_context LIKE '%curriculum personalization%'
            )
            OR (action = 'shown' AND target = 'start_diagnostic')
        ) AS track_id,
        -- first project_id where user selected diagnostics on study plan
        -- or started diagnostics (viewed diagnostics step)
        argMinIf(
            selected_project_id, dt,
            (
                action = 'click'
                AND page LIKE '%/study-plan%'
                AND frontend_context LIKE '%curriculum personalization%'
            )
            OR (action = 'shown' AND target = 'start_diagnostic')
        ) AS project_id,
        dictGetDateTime(
            'hyperskill.alt_users_stepikuser_dict',
            'date_registered',
            user_id
        ) AS registered_dt,
        minIf(
            dt,
            action = 'click'
            AND page LIKE '%/study-plan%'
            AND frontend_context LIKE '%curriculum personalization%'
        ) AS selected_diagnostics_dt,
        minIf(
            dt, (action = 'view' AND page LIKE '%diagnostics/step/%')
            OR (action = 'viewed_step' AND solving_context = 'diagnostic')
            OR (action = 'shown' AND target = 'start_diagnostic')
        ) AS started_diagnostics_dt,
        minIf(
            dt,
            action = 'click'
            AND (
                (page LIKE '%/diagnostics%' AND target = 'skip_diagnostics')
                OR (page = '/diagnostics' AND page_part = 'main' AND target = 'skip') --noqa
            )
        ) AS skipped_diagnostics_dt,
        minIf(
            dt,
            (action = 'view' AND page LIKE '%diagnostics/step/%')
            OR (action = 'viewed_step' AND solving_context = 'diagnostic')
        ) AS viewed_diagnostics_step_dt,
        minIf(
            dt,
            action IN (
                'completed_submission', 'failed_submission',
                'completed_step'
            )
            AND solving_context = 'diagnostic'
        ) AS tried_to_solve_diagnostics_step_dt,
        minIf(
            dt,
            action IN ('completed_submission', 'completed_step')
            AND solving_context = 'diagnostic'
        ) AS completed_diagnostics_step_dt,
        minIf(
            dt,
            page LIKE '%diagnostics/step/%' AND target = 'cant_solve'
        ) AS skipped_diagnostics_step_dt,
        -- we can have action = 'completed_diagnostics' for users who
        -- not started diagnostics ('no experience' in TALG)
        -- or tried to solve 1-3 steps, but didn't complete them
        minIf(dt, action = 'completed_diagnostics') AS completed_diagnostics_dt --noqa

    FROM hyperskill.content

    WHERE
        date >= today() - INTERVAL 6 MONTH
        AND registration_date BETWEEN today() - INTERVAL 6 MONTH
        AND today() - INTERVAL 1 DAY
        AND action IN (
            'click', 'view', 'shown', 'completed_submission', 'failed_submission', --noqa
            'completed_step', 'completed_diagnostics', 'registered_user'
        )
        AND user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased)

    GROUP BY user_id

    HAVING registered_dt > toDateTime('2017-01-01')

    ORDER BY user_id
),

users_diagnostics_activity AS (

    SELECT
        content.user_id AS user_id,
        -- activity in diagnostics
        uniqExactIf(
            content.step_id,
            content.action IN ('completed_submission', 'failed_submission', 'completed_step') --noqa
            AND content.solving_context = 'diagnostic'
            AND content.selected_track_id = user_diagnostics_dts.track_id
            AND content.selected_project_id = user_diagnostics_dts.project_id
            AND content.dt BETWEEN started_diagnostics_dt AND started_diagnostics_dt + INTERVAL 12 HOUR --noqa
        ) AS tried_to_solve_steps_in_diagnostics_count,
        uniqExactIf(
            content.step_id, content.action IN ('completed_submission', 'completed_step') --noqa
            AND content.solving_context = 'diagnostic'
            AND content.selected_track_id = user_diagnostics_dts.track_id
            AND content.selected_project_id = user_diagnostics_dts.project_id
            AND content. dt BETWEEN started_diagnostics_dt AND started_diagnostics_dt + INTERVAL 12 HOUR --noqa
        ) AS completed_steps_in_diagnostics_count,
        uniqExactIf(
            (splitByString('/diagnostics/step/', content.page)[2] AS skipped_step_id), --noqa
            content.page LIKE '%diagnostics/step/%' AND content.target = 'cant_solve' --noqa
            AND content.selected_track_id = user_diagnostics_dts.track_id --noqa
            AND content.selected_project_id = user_diagnostics_dts.project_id --noqa
            AND content.dt BETWEEN started_diagnostics_dt AND started_diagnostics_dt + INTERVAL 12 HOUR --noqa
        ) AS skipped_steps_in_diagnostics_count

    FROM hyperskill.content AS content

    LEFT JOIN user_diagnostics_dts USING user_id

    WHERE
        content.date >= today() - INTERVAL 6 MONTH
        AND content.registration_date BETWEEN today() - INTERVAL 6 MONTH
        AND today() - INTERVAL 1 DAY
        AND content.action IN
        (
            'shown', 'completed_submission', 'failed_submission',
            'completed_step', 'completed_diagnostics'
        )
        AND user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased)

    GROUP BY user_id

),

users_diagnostics_conversions AS (

    SELECT
        user_diagnostics_dts.user_id,
        user_diagnostics_dts.track_id,
        user_diagnostics_dts.project_id,
        user_dts.registered_dt AS registered_dt,
        user_dts.selected_diagnostics_dt AS selected_diagnostics_dt,
        user_dts.started_diagnostics_dt AS started_diagnostics_dt,
        user_dts.skipped_diagnostics_dt AS skipped_diagnostics_dt,
        user_dts.viewed_diagnostics_step_dt AS viewed_diagnostics_step_dt,
        user_dts.tried_to_solve_diagnostics_step_dt AS solved_diagnostics_step_dt, --noqa
        user_dts.completed_diagnostics_step_dt AS completed_diagnostics_step_dt,
        user_dts.skipped_diagnostics_step_dt AS skipped_diagnostics_step_dt,
        user_dts.completed_diagnostics_dt AS completed_diagnostics_dt,
        user_act.completed_steps_in_diagnostics_count AS completed_steps_in_diagnostics_count, --noqa
        user_act.skipped_steps_in_diagnostics_count AS skipped_steps_in_diagnostics_count, --noqa
        user_act.tried_to_solve_steps_in_diagnostics_count AS tried_to_solve_steps_in_diagnostics_count, --noqa
        if(
            user_dts.selected_diagnostics_dt
            BETWEEN user_dts.registered_dt AND user_dts.registered_dt + INTERVAL 6 DAY, 1, 0 --noqa
        ) AS is_selected_diagnostics,
        if(
            user_dts.started_diagnostics_dt
            BETWEEN user_dts.registered_dt AND user_dts.registered_dt + INTERVAL 6 DAY, 1, 0 --noqa
        ) AS is_started_diagnostics,
        if(
            user_dts.skipped_diagnostics_dt
            BETWEEN user_dts.started_diagnostics_dt AND user_dts.started_diagnostics_dt + INTERVAL 12 HOUR --noqa
            AND user_dts.started_diagnostics_dt > toDate('2020-01-01'),
            1, 0
        ) AS is_skipped_diagnostics,
        if(
            user_dts.viewed_diagnostics_step_dt
            BETWEEN user_dts.started_diagnostics_dt AND user_dts.started_diagnostics_dt + INTERVAL 12 HOUR --noqa
            AND user_dts.started_diagnostics_dt > toDate('2020-01-01'),
            1, 0
        ) AS is_viewed_diagnostics_step,
        if(
            user_dts.tried_to_solve_diagnostics_step_dt
            BETWEEN user_dts.started_diagnostics_dt AND user_dts.started_diagnostics_dt + INTERVAL 12 HOUR --noqa
            AND user_dts.started_diagnostics_dt > toDate('2020-01-01'),
            1, 0
        ) AS is_tried_to_solve_diagnostics_step,
        if(
            user_dts.completed_diagnostics_step_dt
            BETWEEN user_dts.started_diagnostics_dt AND user_dts.started_diagnostics_dt + INTERVAL 12 HOUR --noqa
            AND user_dts.started_diagnostics_dt > toDate('2020-01-01'),
            1, 0
        ) AS is_completed_diagnostics_step,
        if(
            user_dts.skipped_diagnostics_step_dt
            BETWEEN user_dts.started_diagnostics_dt AND user_dts.started_diagnostics_dt + INTERVAL 12 HOUR --noqa
            AND user_dts.started_diagnostics_dt > toDate('2020-01-01'),
            1, 0
        ) AS is_skipped_diagnostics_step,
        if(
            user_dts.completed_diagnostics_dt
            BETWEEN user_dts.started_diagnostics_dt AND user_dts.started_diagnostics_dt + INTERVAL 12 HOUR --noqa
            AND user_dts.started_diagnostics_dt > toDate('2020-01-01'),
            1, 0
        ) AS is_completed_diagnostics

    FROM user_diagnostics_dts AS user_dts
    LEFT JOIN users_diagnostics_activity AS user_act USING user_id
    WHERE registered_dt > toDateTime('2017-01-01')
)

SELECT *
FROM users_diagnostics_conversions

-- int_users__topics_activity_conversions.sql

-- TODO: update solving_context after ALT-8937 Change `solving_context`
--  filling for actions with topics (events)
SELECT
    user_id,
    selected_track_id AS track_id,
    selected_project_id AS project_id,
    topic_id,
    retention(
        1,
        action = 'skipped_predicted_topic',
        action IN (
            'completed_submission', 'failed_submission', 'completed_step'
        )
        AND solving_context = 'verification',
        action = 'skipped_nonpredicted_topic',
        action IN ('completed_submission', 'failed_submission')
        AND solving_context IN ('default', ''),
        action = 'completed_topic'
        AND solving_context IN ('by_steps', 'default', 'by_stages'),
        action = 'completed_predicted_topic',
        action IN ('viewed_step', 'completed_step') AND step_type = 'text'
    ) AS topic_actions,
    -- user-topic conversions
    -- clicked 'skip' in study plan = skipped topic
    topic_actions[2] AS is_skipped_preskipped_topic,
    -- clicked 'verify to skip' in study plan and send submission
    topic_actions[3] AS is_tried_skip_topic,
    -- clicked 'verify to skip' in study plan and completed step
    -- during 3 attempts - skipped topic through verification
    topic_actions[4] AND is_tried_skip_topic AS is_verified_topic,
    topic_actions[5] AS is_tried_solve_topic_by_steps,
    topic_actions[6]
    AND is_tried_solve_topic_by_steps AS is_completed_topic_by_steps,
    topic_actions[7]
    AND is_tried_solve_topic_by_steps AS is_completed_preskipped_topic_by_steps,
    topic_actions[8] AS is_viewed_theory,
    -- user-topic activity
    minIf(dt, action IN (
        'completed_topic', 'skipped_topic', 'skipped_predicted_topic',
        'skipped_nonpredicted_topic', 'completed_predicted_topic'
    )) AS topic_completion_or_skip_dt,
    minIf(
        dt,
        action IN (
            'completed_submission', 'failed_submission', 'completed_step'
        )
        AND step_type != 'text'
    ) AS topic_first_submission_dt,
    1
    - countIf(
        action = 'completed_submission' AND solving_context IN ('default', '')
    )
    / countIf(
        action IN ('completed_submission', 'failed_submission')
        AND solving_context IN ('default', '')
    ) AS failure_rate_by_steps,
    uniqExactIf(
        step_id, action IN ('completed_step', 'completed_submission')
        AND solving_context IN ('default', '')
        AND step_type != 'text'
    ) AS completed_steps

FROM hyperskill.content

WHERE
    date >= today() - INTERVAL 6 MONTH
    AND registration_date >= today() - INTERVAL 6 MONTH
    AND topic_id > 0
    AND action IN (
        'completed_submission', 'failed_submission', 'completed_step',
        'skipped_topic', 'skipped_predicted_topic', 'completed_topic',
        'skipped_nonpredicted_topic', 'completed_predicted_topic', 'click',
        'viewed_step'
    )
    AND user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased
    )
    AND selected_track_id > 0
    -- to to filter only those topics and actions that were in study plan
    AND selected_track_id = track_id
    AND selected_project_id = project_id

GROUP BY user_id, topic_id, project_id, track_id

ORDER BY user_id, track_id, project_id, topic_id

-- int_users__topics_unskip_dts__by_track_project_agg.sql

-- for unskip topic in hyperskill.content
-- we have only frontend actions with topic_id = 0,
-- we can calculate only events count
-- (not defined (unique) unskipped topics)
-- so, this metric can be not-accurate

SELECT
    user_id,
    selected_track_id AS track_id,
    selected_project_id AS project_id,
    -- clicked 'unskip' in study plan, topic theory page or knowledge map
    groupArray(dt) AS unskipped_topic_dts

FROM hyperskill.content

WHERE
    date >= today() - INTERVAL 6 MONTH
    AND registration_date >= today() - INTERVAL 6 MONTH
    AND action = 'click'
    -- unskip topic in study plan
    AND (
        (
            page_part = 'stage'
            AND page LIKE '%/study-plan%'
            AND target = 'activity_unskip'
            AND frontend_context LIKE '%learn topic%'
        )
        OR
        -- unskip topic in topic theory page and knowledge map
        (
            target = 'unskip_topic'
            AND page_part IN ('main', 'step_text', 'topic_context_menu')
        )
    )
    AND user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased)
    AND selected_track_id > 0

GROUP BY user_id, project_id, track_id
ORDER BY user_id

-- ","The query is broken down into three main parts:

1. User Diagnostics Activity: This part focuses on capturing the first occurrence of various diagnostic-related actions by users, such as selecting a track or project, starting diagnostics, skipping diagnostics, viewing a diagnostics step, attempting to solve a diagnostics step, and completing diagnostics.

2. Users Diagnostics Conversions: This part joins the user diagnostics activity with additional metrics to determine whether certain actions occurred within specific time frames after registration or starting diagnostics. It also calculates various flags indicating whether a user has performed certain actions like selecting, starting, or completing diagnostics.

3. User Topics Activity and Conversions: This part captures user interactions with topics, including skipping topics, attempting to skip topics, verifying topics, completing topics, and viewing theory. It also calculates metrics such as the date of topic completion or skip, the date of the first submission for a topic, the failure rate by steps, and the count of completed steps.

4. User Topics Unskip Dates: This part aggregates dates when users unskipped topics in their study plan, topic theory page, or knowledge map.

Each part uses various SQL functions and clauses to filter, aggregate, and compute the desired metrics based on user actions recorded in the Hyperskill content database. The query uses common table expressions (CTEs), joins, conditional logic, and aggregation functions to build the final dataset.","Can you provide me with a report on how our users are interacting with the diagnostic tools and topics? I'm interested in when they first start using these features, if they're completing them, and how they're progressing. Also, could you track any instances where users go back to previously skipped topics?"
"WITH topic_stats AS (SELECT topic_id,
                            uniqExact(user_id)                                     AS completed_step_users,
                            row_number() over (order by completed_step_users DESC) AS topic_rank
                     FROM hyperskill.content
                     WHERE dt >= today() - 28 * 3
                       AND action IN ('completed_submission', 'completed_step')
                       AND topic_id > 0
                       AND step_type != 'text'
                       AND solving_context IN ('', 'default')
                       AND topic_id IN (SELECT topic_id
                                        FROM hyperskill.stg_topics
                                        WHERE is_enabled = 1
                                          AND is_group = 0
                                          AND is_manual_disabled = 0
                                          AND has_steps = 1
                                          AND deleted_at is null)
                     GROUP BY topic_id
                     ORDER BY completed_step_users DESC),
     -- topics count
     max_rank AS (SELECT max(topic_rank) AS topics_count
                  FROM topic_stats)
-- get first 10% rows from topic_stats
SELECT topic_id,
       completed_step_users
FROM topic_stats
WHERE topic_rank <= (SELECT topics_count FROM max_rank) * 0.1;","1. The expected result of the query is a list of topic IDs and the number of unique users who have completed a step or submission for each topic, ranked by the number of completed users. Only the top 10% of topics by this rank will be returned.

2. The query is broken down into two logical parts: 
   - topic_stats
   - max_rank

3. Part 'topic_stats':
   - Select the 'topic_id' and count the distinct 'user_id' as 'completed_step_users'.
   - Rank the topics by 'completed_step_users' in descending order using the 'row_number()' function, naming this rank as 'topic_rank'.
   - Filter the data where 'dt' is within the last 84 days, 'action' is either 'completed_submission' or 'completed_step', 'topic_id' is greater than 0, 'step_type' is not 'text', and 'solving_context' is either empty or 'default'.
   - Further filter 'topic_id' to include only those present in a subquery from 'hyperskill.stg_topics' where 'is_enabled' is 1, 'is_group' is 0, 'is_manual_disabled' is 0, 'has_steps' is 1, and 'deleted_at' is null.
   - Group the results by 'topic_id' and order them by 'completed_step_users' in descending order.

4. Part 'max_rank':
   - Select the maximum value of 'topic_rank' from 'topic_stats' as 'topics_count'.

5. Final Selection:
   - Select 'topic_id' and 'completed_step_users' from 'topic_stats'.
   - Limit the results to those where 'topic_rank' is less than or equal to 10% of 'topics_count' obtained from 'max_rank'.","Can you provide me with a list of our most engaging topics? Specifically, I'd like to see which topics have the highest number of unique users completing steps or submissions in the last three months. It would be great if you could narrow it down to the top 10% of topics based on user engagement. Please ensure that the topics considered are currently enabled, not part of a group, not manually disabled, have steps, and are not deleted."
"-- days between registration and first premium subscription for new users
SELECT
    median(dateDiff('day', registration_date, date)) AS median,
    avg(dateDiff('day', registration_date, date)) AS avg,
    quantile(0.75)(dateDiff('day', registration_date, date)) AS quantile_75,
    quantile(0.9)(dateDiff('day', registration_date, date)) AS quantile_90
FROM hyperskill.content
WHERE action like '%created_subscription%'
  AND date >= today() - 28 * 3
  AND dt_registered >= today() - 28 * 3
  AND subscription_type = 'premium';","1. Describe the expected query result: The query will calculate statistical measures (median, average, 75th percentile, and 90th percentile) of the number of days between the registration date and the date of the first premium subscription for new users.

2. Logical parts of the query: The query consists of the following parts:
   - Selection of relevant columns and calculation of date differences
   - Filtering conditions
   - Aggregation functions to calculate statistical measures

3. Description of each part:
   - Selection and calculation: We will select users whose actions indicate the creation of a subscription and calculate the difference in days between their 'registration_date' and the 'date' of the action.
   - Filtering conditions: We will apply filters to include only actions related to 'created_subscription', ensure the 'date' of the action and 'dt_registered' are within the last 84 days (28 days * 3), and include only users with a 'subscription_type' of 'premium'.
   - Aggregation functions: We will use aggregation functions to calculate the median, average, 75th percentile, and 90th percentile of the calculated date differences.","Can you provide me with some insights on how quickly new users are deciding to upgrade to a premium subscription? Specifically, I'd like to know the median, average, 75th, and 90th percentile of the number of days it takes from their registration until they first subscribe to premium, but only for the last three months."
"-- retention from registratio to next day (24-48 hours) activation, view (vist)
SELECT avg(next_day_retention)      AS next_day_active_retention,
       avg(next_day_view_retention) AS next_day_view_retention
FROM (
         SELECT user_id,
                dictGetDateTime('hyperskill.alt_users_stepikuser_dict',
                                'date_registered',
                                toUInt64(user_id))                                                             AS cohort,
                retention(1, dt BETWEEN dt_registered + interval 24 hour AND dt_registered + interval 48 hour
                    AND action = 'completed_step'
                    AND step_type !='text')[2]                                                                 AS next_day_retention,
                retention(1,
                          dt BETWEEN dt_registered + interval 24 hour AND dt_registered + interval 48 hour)[2] AS next_day_view_retention
         FROM hyperskill.content
         WHERE date >= today() - 28 * 3
           AND dt_registered BETWEEN today() - 28 * 3 AND today() - 1
           AND action IN ('registered_user', 'completed_step', 'viewed_step', 'view')
           AND is_superuser = 0
           AND is_biased = 0
           AND user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased)
         GROUP BY user_id, cohort
         );","The expected result of the query is to calculate the average next-day active retention and next-day view retention rates for users who registered within a specific time frame. The query will be broken down into the following logical parts:

1. Subquery (Inner Query):
   - Select user_id and calculate the cohort date using the dictGetDateTime function.
   - Calculate next_day_retention by checking if the user completed a step (excluding text steps) between 24 and 48 hours after registration.
   - Calculate next_day_view_retention by checking if the user had any view action between 24 and 48 hours after registration.
   - Filter the data to include only actions within the last 84 days (28 days * 3) and registrations between the last 84 days and yesterday.
   - Exclude superusers and biased users, and also filter out users identified as biased in the hyperskill.users_is_biased table.
   - Group the results by user_id and cohort.

2. Outer Query:
   - Calculate the average of next_day_retention and next_day_view_retention from the subquery results.

Column names to be used include: user_id, date_registered, dt, dt_registered, action, step_type, is_superuser, is_biased, and next_day_retention, next_day_view_retention.","Can you provide me with the average rates of users coming back the next day to complete a step and to view content after they've registered? I'm interested in the data for users who signed up in the last three months, but please exclude any superusers or users flagged as biased."
"-- Active users count for each track for last 3 month, 1 month, 1 month with subscription info
SELECT selected_track_id,
       dictGetString('hyperskill.tracks_track_dict', 'title', toUInt64(selected_track_id)) AS track_title,
       uniqExactIf(user_id, (date >= (now() - toIntervalMonth(3))) AND
                            (date <= now()))                                               AS active_last_3_month,
       uniqExactIf(user_id, (date >= (now() - toIntervalMonth(1))) AND
                            (date <= now()))                                               AS active_last_1_month,
       uniqExactIf(user_id, ((date >= (now() - toIntervalMonth(1))) AND (date <= now())) AND
                            (subscription_type IN ('personal', 'premium')))                AS active_last_1_month_personal_premium,
       uniqExactIf(user_id, ((date >= (now() - toIntervalMonth(1))) AND (date <= now())) AND
                            (subscription_type IN ('free', 'freemium')))                   AS active_last_1_month_free,
       uniqExactIf(user_id, ((date >= (now() - toIntervalMonth(1))) AND (date <= now())) AND
                            (subscription_type = 'trial'))                                 AS active_last_1_month_trial,
       uniqExactIf(user_id, ((date >= (now() - toIntervalMonth(1))) AND (date <= now())) AND
                            (subscription_type = 'organization trial'))                    AS active_last_1_month_org_trial,

       uniqExactIf(user_id, ((date >= (now() - toIntervalMonth(1))) AND (date <= now())) AND
                            (subscription_type IN ('commercial', 'team member')))          AS active_last_1_month_commercial
FROM hyperskill.content
WHERE (date >= (today() - toIntervalMonth(3)))
  AND (action IN
       ('failed_submission', 'completed_submission', 'completed_step', 
        'completed_stage', 'completed_project'))
  AND (step_type != 'text')
  AND (solving_context IN ('', 'default'))
  AND (selected_track_id = track_id)
  AND (user_id NOT IN (SELECT user_id
                       FROM hyperskill.users_is_biased))
  AND (dt_registered > toDateTime(0))
  AND dictGetInt8('hyperskill.tracks__dict', 'is_enabled', toUInt64(track_id))
  AND (user_id > 0)
  AND (track_id > 0)
GROUP BY selected_track_id
ORDER BY active_last_1_month DESC;","1. The expected result of the query is a list of tracks with their titles, along with the count of unique active users for each track over different time periods: the last 3 months, the last month, and the last month broken down by different subscription types (personal, premium, free, freemium, trial, organization trial, commercial, team member).

2. The logical parts of the query are:
   - Track Identification
   - Active User Counts
   - Subscription Type Breakdown
   - Filtering Criteria
   - Exclusion of Biased Users
   - Grouping and Ordering

3. Descriptions for each part:
   - Track Identification: Retrieve the 'selected_track_id' and its corresponding 'track_title' using a dictionary function.
   - Active User Counts: Calculate the unique count of 'user_id' for the last 3 months and the last month.
   - Subscription Type Breakdown: Calculate the unique count of 'user_id' for the last month, further broken down by 'subscription_type' categories.
   - Filtering Criteria: Apply filters based on 'date', 'action', 'step_type', 'solving_context', 'selected_track_id', 'track_id', 'dt_registered', and 'is_enabled' flag from a dictionary.
   - Exclusion of Biased Users: Exclude 'user_id's that are listed in the 'hyperskill.users_is_biased' table.
   - Grouping and Ordering: Group the results by 'selected_track_id' and order by the count of active users in the last month in descending order.","Can you provide me with a report on how many unique users have been active on each track over the past three months, the past month, and also a breakdown by subscription type for the last month? Please exclude any biased users from the count and rank the tracks by the number of active users in the last month."
"WITH subs AS (SELECT user_id,
                     valid_till AS sub_valid_till,
                     is_auto_renewal
              FROM hyperskill_private.stg_subscriptions
              WHERE period = 'annual'
                AND type = 'personal'
                AND valid_till BETWEEN '2023-10-01' AND '2023-11-30'
                -- subscription was not closed too early (suspicious subs)
                AND dateDiff('day', start_from, valid_till) > 300
                -- and user has no other subs after
                AND user_id NOT IN (SELECT user_id
                                FROM hyperskill_private.stg_subscriptions
                                WHERE type IN ('personal', 'premium')
                                  AND start_from >= '2023-10-01')
),
     users AS (SELECT user_id,
                      email,
                      selected_track,
                      passed_problems,
                      date_registered,
                      is_active_last_1_month,
                      is_active_last_2_months,
                      is_active_last_3_months,
                      country,
                      is_subscribed_for_marketing
               FROM hyperskill_private.registered_users
               WHERE user_id IN (SELECT user_id FROM subs)
)
SELECT *
FROM subs
         LEFT JOIN users USING user_id
WHERE user_id > 0
ORDER BY sub_valid_till;","1. Describe the expected query result: The query is expected to return a list of users with annual personal subscriptions that are valid between October 1, 2023, and November 30, 2023, who have not closed their subscriptions too early (more than 300 days), do not have any other subscriptions starting from October 1, 2023, and are registered users. The result will include subscription details, user details, and will be ordered by the subscription's valid till date.

2. Break down the query into logical parts: The query consists of two Common Table Expressions (CTEs) and a final SELECT statement.

3. Part descriptions:

- CTE 'subs': This part will select user IDs, subscription valid till dates, and auto-renewal status from the 'stg_subscriptions' table where the subscription period is 'annual', the type is 'personal', the valid till date is between October 1, 2023, and November 30, 2023, the subscription duration is more than 300 days, and the user does not have any other 'personal' or 'premium' subscriptions starting on or after October 1, 2023.

- CTE 'users': This part will select user details such as user ID, email, selected track, passed problems, date registered, activity status for the last 1, 2, and 3 months, country, and marketing subscription status from the 'registered_users' table where the user ID is in the list obtained from the 'subs' CTE.

- Final SELECT statement: This part will combine the results from the 'subs' and 'users' CTEs using a LEFT JOIN on the user ID, filter out any records with a user ID less than or equal to 0, and order the final result by the subscription's valid till date.","Can you provide me with a list of registered users who have an active annual personal subscription valid between October 1 and November 30, 2023, and who haven't canceled their subscriptions prematurely? Please ensure these users don't have any other subscriptions starting from October 1, and include their subscription details, personal details, and sort the list by the subscription end date."
"-- https://vyahhi.myjetbrains.com/youtrack/issue/AN-1828/
-- Measure the effect of reactivation:
-- * How many users reactivated daily?
-- * What is their retention?
-- * How many reactivated users bought subscriptions?


CREATE OR REPLACE VIEW hyperskill_reports.reactivated_users
AS
WITH

toUInt16(28 * 6 - 1) AS calculation_depth_days,
toUInt16(28) AS reactivation_window,

users_submissions AS (

    -- Get users submission dates and define the previous submission date
    SELECT DISTINCT
        user_id,
        registration_date,
        date AS submission_date
    FROM hyperskill.content
    WHERE date > today() - calculation_depth_days - reactivation_window - 1
        AND action IN (
            'rejected_submission',
            'failed_submission',
            'completed_submission'
        )
        AND is_superuser = 0
        AND is_biased = 0
        AND registration_date > toDate('2017-01-01')

    ORDER BY
        user_id, date

),

users_data AS (

    SELECT
        user_id,
        registration_date,
        submission_date,
        any(submission_date)
            OVER(PARTITION BY user_id
                ORDER BY submission_date
                ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) AS prev_submission_date
    FROM users_submissions

),

reactivation_dates AS (

    -- Get reactivation dates for users – the day when a user returns 
    -- after 28 days since the last submission or registration date
    SELECT
        user_id,
        submission_date AS reactivation_date
    FROM users_data
    WHERE
        submission_date - prev_submission_date > reactivation_window
        AND submission_date - toDate(registration_date) > reactivation_window

),

reactivation_retention AS (

    -- Calculate the retention after reactivation
    SELECT
        user_id,
        any(registration_date) AS registration_date,
        reactivation_date,
        retention(
            1,
            submission_date = reactivation_date + toIntervalDay(1),
            submission_date = reactivation_date + toIntervalDay(7),
            submission_date = reactivation_date + toIntervalDay(14),
            submission_date = reactivation_date + toIntervalDay(21),
            submission_date = reactivation_date + toIntervalDay(35)
        ) AS retentions_by_days,
        retention(
            1,
            submission_date BETWEEN reactivation_date + toIntervalDay(7 * 1 + 1)
                AND reactivation_date + toIntervalDay(7 * 2),
            submission_date BETWEEN reactivation_date + toIntervalDay(7 * 2 + 1)
                AND reactivation_date + toIntervalDay(7 * 3),
            submission_date BETWEEN reactivation_date + toIntervalDay(7 * 3 + 1)
                AND reactivation_date + toIntervalDay(7 * 4),
            submission_date BETWEEN reactivation_date + toIntervalDay(7 * 4 + 1)
                AND reactivation_date + toIntervalDay(7 * 5),
            submission_date BETWEEN reactivation_date + toIntervalDay(7 * 5 + 1)
                AND reactivation_date + toIntervalDay(7 * 6),
            submission_date BETWEEN reactivation_date + toIntervalDay(7 * 6 + 1)
                AND reactivation_date + toIntervalDay(7 * 7),
            submission_date BETWEEN reactivation_date + toIntervalDay(7 * 7 + 1)
                AND reactivation_date + toIntervalDay(7 * 8),
            submission_date BETWEEN reactivation_date + toIntervalDay(7 * 8 + 1)
                AND reactivation_date + toIntervalDay(7 * 9),
            submission_date BETWEEN reactivation_date + toIntervalDay(7 * 9 + 1)
                AND reactivation_date + toIntervalDay(7 * 10),
            submission_date BETWEEN reactivation_date + toIntervalDay(7 * 10 + 1)
                AND reactivation_date + toIntervalDay(7 * 11),
            submission_date BETWEEN reactivation_date + toIntervalDay(7 * 11 + 1)
                AND reactivation_date + toIntervalDay(7 * 12),
            submission_date BETWEEN reactivation_date + toIntervalDay(7 * 12 + 1)
                AND reactivation_date + toIntervalDay(7 * 13)
        ) AS retentioins_weekly
    FROM reactivation_dates
    LEFT JOIN users_submissions USING user_id
    GROUP BY
        user_id, reactivation_date

),

new_subscriptions AS (

    -- Get subscriptions and revenue
    SELECT
        hyperskill_user_id AS user_id,
        min(sub_created_at_min) AS first_subscription_dt,
        sum(amount_usd_cents / 100) AS revenue,
        -- Revenue within the first 10 days after SUBSCRIPTION.
        --     It is not the same as Revenue the first 10 days after REACTIVATION, but assume that equals.
        sumIf(amount_usd_cents / 100,
            transaction_dt BETWEEN toDate(sub_created_at_min)
                AND toDate(sub_created_at_min) + toIntervalDay(10)) AS revenue_10d,
        count() AS purchases
    FROM hyperskill_reports.sales
    WHERE
        product_type IN ('premium', 'personal')
        AND amount_usd_cents != 0
        AND hyperskill_user_id > 0
        -- AND transaction_type IN ('payment', 'charge')
        AND sub_created_at_min > today() - calculation_depth_days - reactivation_window - 1
    GROUP BY
        user_id

),

utm AS (

    -- Get UTM parameters. Attribution model is Last Click Before Purchase
    SELECT
        user_id,
        last_click_channel,
        last_click_utm_source,
        last_click_utm_campaign,
        last_click_utm_medium
    FROM hyperskill_reports.marketing_campaign_report

),

result AS (

    -- Combine all metrics in one mart
    SELECT
        reactivation_retention.user_id AS user_id,
        registration_date,
        reactivation_date,
        toMonday(reactivation_date) AS reactivation_week_cohort,
        retentions_by_days,
        retentioins_weekly,
        first_subscription_dt >= reactivation_date AS is_subscribed_after_reactivation,
        first_subscription_dt BETWEEN reactivation_date
            AND reactivation_date + toIntervalDay(10) AS is_subscribed_after_reactivation_10d,
        if(first_subscription_dt >= reactivation_date, revenue, 0) AS reactivated_revenue,
        if(first_subscription_dt >= reactivation_date, revenue_10d, 0) AS reactivated_revenue_10d,
        if(first_subscription_dt >= reactivation_date, purchases, 0) AS reactivated_purchases,
        last_click_channel,
        last_click_utm_source,
        last_click_utm_campaign,
        last_click_utm_medium
    FROM reactivation_retention
    LEFT JOIN new_subscriptions ON new_subscriptions.user_id = reactivation_retention.user_id
    LEFT JOIN utm ON utm.user_id = reactivation_retention.user_id

)

SELECT
    *
FROM result;","The query is designed to create a view named 'hyperskill_reports.reactivated_users' that will provide insights into user reactivation, retention, and subscription purchases on the Hyperskill platform. The expected result is a comprehensive dataset that includes user IDs, registration dates, reactivation dates, retention metrics, subscription information, and UTM parameters for marketing analysis.

The query is broken down into the following logical parts:
1. Constants Definition
2. Users Submissions
3. Users Data
4. Reactivation Dates
5. Reactivation Retention
6. New Subscriptions
7. UTM Parameters
8. Final Result Combination
9. View Creation

Each part is briefly described below using the specified column names:

1. Constants Definition: Define constants 'calculation_depth_days' and 'reactivation_window' to be used in the query.

2. Users Submissions: Select distinct user submissions, filtering by date, action types, and excluding superusers and biased users. Order by user ID and date.

3. Users Data: For each user, select the user ID, registration date, submission date, and calculate the previous submission date.

4. Reactivation Dates: Identify reactivation dates for users by comparing submission dates with previous submission dates and registration dates.

5. Reactivation Retention: Calculate retention metrics for reactivated users by comparing submission dates with reactivation dates at various intervals.

6. New Subscriptions: Aggregate subscription data for users, including the date of the first subscription, revenue, revenue within the first 10 days, and the number of purchases.

7. UTM Parameters: Select the last click UTM parameters for marketing campaign analysis.

8. Final Result Combination: Combine all the metrics from the previous parts into a single dataset, including user IDs, registration dates, reactivation dates, retention metrics, subscription information, and UTM parameters.

9. View Creation: Create the view 'hyperskill_reports.reactivated_users' with the dataset obtained from the final result combination.","Can we get a report on users who have come back to Hyperskill after a break? It would be great to see when they re-registered, how well they're sticking with the platform, and if they're buying any subscriptions. Also, if we could understand which marketing campaigns brought them back, that would be super helpful for our strategy."
"WITH

subscriptions AS (

SELECT
    user_id,
    email,
    sub_personal_dts['created_at_min'] AS personal_created_at_min,
--     sub_personal_dts['start_from_max'] AS personal_start_from_max,
--     sub_personal_dts['valid_till_max'] AS personal_valid_till_max,

    sub_premium_dts['created_at_min'] AS premium_created_at_min,
--     sub_premium_dts['start_from_max'] AS premium_start_from_max,
--     sub_premium_dts['valid_till_max'] AS premium_valid_till_max,

    sub_freemium_dts['created_at_min'] AS freemium_created_at_min,
--     sub_freemium_dts['start_from_max'] AS freemium_start_from_max,
--     sub_freemium_dts['valid_till_max'] AS freemium_valid_till_max,

    sub_org_dts,
    date_registered,
    bought_paid_subscription,
    has_valid_paid_subscription,
    sub_created_at_least
FROM hyperskill_private.registered_users
WHERE
    is_biased = 0
    AND is_superuser = 0
    AND user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased)
    AND country NOT IN ('Russia', 'Belarus')
),

-- 1 файл: почты пользователей,
-- которые хотя бы один раз купили персональную или премиум подписку с 01.01.2023 по 04.06.2023
result_1 AS (

SELECT
    email
FROM subscriptions
WHERE
    personal_created_at_min BETWEEN toDate('2023-01-01') AND toDate('2023-06-04') + 1
    OR premium_created_at_min BETWEEN toDate('2023-01-01') AND toDate('2023-06-04') + 1
    OR user_id IN (SELECT
                        DISTINCT user_id
                    FROM hyperskill_private.stg_subscriptions__hist
                    WHERE
                        start_from BETWEEN toDate('2023-01-01') AND toDate('2023-06-04') + 1
                        AND type IN ('personal', 'premium'))
),

-- 2 файл: почты пользователей, зарегистрировавшихся после 01.01.2023
-- и не имеющих за всё время никакой подписки (ни персональной, ни премиум, ни корпоративной).
-- Исключая пользователей модели Freemium.
result_2 AS (

SELECT
    email
FROM subscriptions
WHERE
    date_registered >= toDate('2023-01-01')
    AND bought_paid_subscription = 0
    AND freemium_created_at_min IS NULL

),

-- 3 файл: почты пользователей, которые сейчас имеют персональную подписку, премиум подписку
-- или корпоративную подписку, или покупали годовую подписку хотя бы раз с 01.01.2022.
result_3 AS (

SELECT
    email
FROM subscriptions
WHERE
    has_valid_paid_subscription = 1
    OR user_id IN (
        SELECT
            user_id
        FROM hyperskill_private.stg_subscriptions__hist
        WHERE
            period = 'annual'
            --AND type = 'personal'
            AND created_at >= toDate('2022-01-01')
    )
)

SELECT
    *
FROM result_1;","The query is designed to generate three separate lists of user emails based on different criteria related to their subscription status. The final output will be the first list of emails.

1. Common Table Expression (CTE) - subscriptions:
   - Select user details from the 'hyperskill_private.registered_users' table.
   - Filter out biased users, superusers, and users from specific countries.
   - Extract minimum creation dates for personal, premium, and freemium subscriptions.
   - Include additional subscription-related fields and the date of registration.

2. CTE - result_1:
   - From the 'subscriptions' CTE, select emails of users who have purchased a personal or premium subscription between specific dates.
   - Include users who have a relevant subscription history in 'hyperskill_private.stg_subscriptions__hist'.

3. CTE - result_2:
   - From the 'subscriptions' CTE, select emails of users who registered after a specific date and have no subscription history, excluding freemium users.

4. CTE - result_3:
   - From the 'subscriptions' CTE, select emails of users who currently have a valid paid subscription or have purchased an annual subscription since a specific date.

5. Final Selection:
   - Retrieve all records from 'result_1' CTE.",Can you provide me with a list of emails for users who have recently purchased a personal or premium subscription? We're looking to target a campaign for users who've shown interest in our paid plans between certain dates and have a history of relevant subscriptions.
"-- File 1: AN-1648-mvp-rfm-features.sql


-- https://vyahhi.myjetbrains.com/youtrack/issue/AN-1648/MVP-RFM-analysis

-- Features for RFM segmentation.
-- Condition: Users registered last year with personal subscription

-- Needed features:
-- user_id
-- email
-- start date (last purchase)
-- last activity (submission) date
-- Cumulative ltv for each user (revenue)
-- Geo data
-- TALG data

-- Additional features:
-- Used platforms
-- Number of passed problems
-- Number of purchases
-- Number of learning days (days with at least one submission)
-- Number of read emails


-- Dataset with features for RFM segmentation
CREATE OR REPLACE VIEW hyperskill_reports.users_rfm_features AS
WITH
talg_data AS (
    SELECT DISTINCT
        user_id,
        question_1,
        question_2
    FROM hyperskill.polls
    WHERE poll_id = 4
    AND poll = 'tell about yourself'
),

map(
    '1', 'I have no experience, I\'m just starting to learn how to code',
    '2', 'I already have some experience in learning programming',
    '3', 'I am a CS or Software Engineering student/graduate',
    '4', 'I\'ve learned to program before, and now I''m using it professionally',
    '', 'No Data'
) AS talg_question_1_dict,

map(
    '1', 'I want to apply for my first job in programming',
    '2', 'My job requires programming and I want to get better at my current job',
    '3', 'I use a different language/technology and want to change the technology stack',
    '4', 'I want to get better at my non-programming job',
    '5', 'I just want to expand my knowledge / get more practice',
    '6', 'I want to try it out and see if coding is right for me',
    '-1', 'Other',
    '', 'No Data'
) AS talg_question_2_dict,

-- Activity for users registered last year
user_activity AS (
    SELECT
        user_id,
        maxIf(date, action IN ('completed_submission', 'failed_submission')) AS last_submission_date,
        uniqExactIf(date, action IN ('completed_submission', 'failed_submission')) AS learning_days,
        uniqExactIf(step_id, action IN ('completed_submission')) AS passed_problems,
        uniqExactIf(target_id, action = 'read_email_notification') AS read_emails,
        groupUniqArrayIf(platform, platform IN ('web', 'iOS', 'ide', 'Android')) AS platforms,
        length(platforms) AS count_platforms
    FROM hyperskill.content
    WHERE
        user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased) AND
        --date > today() - 7 * 52 - 1 AND
        --registration_date > today() - 7 * 52 - 1 AND
        action IN ('completed_submission', 'failed_submission', 'read_email_notification')
    GROUP BY
        user_id
),

-- Features for users with personal subscription
user_features AS (
    SELECT
        -- User
        id AS user_id,
        email,
        country,
        talg_question_1_dict[talg_data.question_1] AS talg_experience,
        talg_question_2_dict[talg_data.question_2] AS talg_motivation,
        platforms,

        -- Recency
        last_submission_date,
        date_diff(day, last_submission_date, today()) AS days_since_last_submission,
        sub_personal_dts['created_at_min'] AS first_personal_sub_created_at,
        sub_personal_dts['start_from_max'] AS last_personal_sub_start_from, -- +- equal date of last purchase
        date_diff(day, last_personal_sub_start_from, today()) AS days_since_last_personal_sub_start_from,

        -- Frequency
        user_activity.passed_problems AS passed_problems,
        purchases,
        learning_days,

        -- Monetary
        revenue_usd,

        -- Engagement
        -- We don't have a lot of purchases. It can be used instead of a Monetary
        read_emails,
        count_platforms,
        actual_streak_duration

    FROM hyperskill_private.registered_users
    ANY LEFT JOIN talg_data ON talg_data.user_id = registered_users.id
    ANY LEFT JOIN user_activity ON user_activity.user_id = registered_users.id
    WHERE
        user_id NOT IN (SELECT user_id FROM hyperskill.users_is_biased) AND
        --date_registered > today() - 7 * 52 - 1 AND
      -- Exclude B2B users
        sub_org_dts = '{}' AND
        --last_submission_date >= today() - 365 - 30 AND
        (passed_problems > 0 OR first_personal_sub_created_at IS NOT NULL)
)

SELECT
    *
FROM user_features;


-- File 2: AN-1648-mvp-rfm-segments.sql

-- https://vyahhi.myjetbrains.com/youtrack/issue/AN-1648/MVP-RFM-analysis

-- R - calculate from date of last purchase and last activity
-- F - calculate as a function from ~number of purchase~ number of solved problems and a number of days when user actually learned
-- M - calculate from a total money spent on hyperskill


CREATE OR REPLACE VIEW hyperskill_reports.users_rfm_scores AS
WITH
-- Quantiles for rank customers from 1-3
rfm_quantiles AS (

    SELECT
        quantiles(0.33, 0.66)(days_since_last_submission) AS days_since_last_submission_quantiles,
        quantiles(0.33, 0.66)(days_since_last_personal_sub_start_from) AS days_since_last_personal_sub_start_from_quantiles,
        quantiles(0.33, 0.66)(passed_problems) AS passed_problems_quantiles,
        --quantiles(0.33, 0.66)(purchases) AS purchases_quantiles, -- [1, 1]
        quantiles(0.33, 0.66)(learning_days) AS learning_days_quantiles,
        quantiles(0.33, 0.66)(revenue_usd) AS revenue_usd_quantiles
        --quantiles(0.33, 0.66)(read_emails) AS read_emails_quantiles  -- [0, 2]
        --quantiles(0.33, 0.66)(count_platforms) AS count_platforms_quantiles -- [2, 2]
        --quantiles(0.33, 0.66)(actual_streak_duration) AS actual_streak_duration -- [0, 0]
    FROM hyperskill_reports.users_rfm_features
    WHERE
        -- ranks calculated only on subscribers
        revenue_usd > 0 AND
        first_personal_sub_created_at IS NOT NULL

)

SELECT
    user_id,
    email,
    country,
    talg_experience,
    talg_motivation,

    -- Recency
    last_submission_date,
    days_since_last_submission,
    days_since_last_submission_quantiles,
    arraySum(arrayMap(x -> (x >= days_since_last_submission),
        days_since_last_submission_quantiles)) + 1 AS days_since_last_submission_score,

    last_personal_sub_start_from,
    days_since_last_personal_sub_start_from,
    days_since_last_personal_sub_start_from_quantiles,
    arraySum(arrayMap(x -> (x >= assumeNotNull(days_since_last_personal_sub_start_from)),
        days_since_last_personal_sub_start_from_quantiles)) + 1 AS days_since_last_personal_sub_start_from_score,

    -- Frequency
    passed_problems,
    passed_problems_quantiles,
    arraySum(arrayMap(x -> (x <= passed_problems), passed_problems_quantiles)) + 1 AS passed_problems_score,
    purchases,

    learning_days,
    learning_days_quantiles,
    arraySum(arrayMap(x -> (x <= learning_days), learning_days_quantiles)) + 1 AS learning_days_score,

    -- Monetary
    revenue_usd,
    revenue_usd_quantiles,
    arraySum(arrayMap(x -> (x <= revenue_usd), revenue_usd_quantiles)) + 1 AS revenue_usd_score,

    -- Engagement
    read_emails,
    count_platforms,
    actual_streak_duration,

    -- RFM
    days_since_last_submission_score AS recency,

    multiIf(
        learning_days_score = 1 AND passed_problems_score IN (1, 2), 1,
        learning_days_score = 3 AND passed_problems_score IN (2, 3), 3,
        2
    ) AS frequency,

    revenue_usd_score AS monetary,

    concat(toString(recency), toString(frequency), toString(monetary)) AS rfm_score

FROM hyperskill_reports.users_rfm_features
INNER JOIN rfm_quantiles ON 1 = 1;


-- Statistics for segments
WITH rfm_data AS (
    SELECT
        DISTINCT
        rfm_score,
        uniqExact(user_id) OVER() AS users,
        uniqExact(user_id) OVER(PARTITION BY rfm_score) AS users_in_segment
    FROM hyperskill_reports.users_rfm_scores
)
SELECT
    rfm_score,
    users_in_segment,
    users_in_segment / users * 100 AS percent
FROM rfm_data;


-- recency distribution
WITH rfm_data AS (
    SELECT
        DISTINCT
        recency,
        uniqExact(user_id) OVER() AS users,
        uniqExact(user_id) OVER(PARTITION BY recency) AS users_in_segment
    FROM hyperskill_reports.users_rfm_scores
)
SELECT
    recency,
    users_in_segment,
    users_in_segment / users * 100 AS percent
FROM rfm_data;


-- frequency distribution
WITH rfm_data AS (
    SELECT
        DISTINCT
        frequency,
        uniqExact(user_id) OVER() AS users,
        uniqExact(user_id) OVER(PARTITION BY frequency) AS users_in_segment
    FROM hyperskill_reports.users_rfm_scores
)
SELECT
    frequency,
    users_in_segment,
    users_in_segment / users * 100 AS percent
FROM rfm_data;


-- monetary distribution
WITH rfm_data AS (
    SELECT
        DISTINCT
        monetary,
        uniqExact(user_id) OVER() AS users,
        uniqExact(user_id) OVER(PARTITION BY monetary) AS users_in_segment
    FROM hyperskill_reports.users_rfm_scores
)
SELECT
    monetary,
    users_in_segment,
    users_in_segment / users * 100 AS percent
FROM rfm_data;

","1. The expected result of the query is a dataset containing features for RFM (Recency, Frequency, Monetary) segmentation of users who registered last year with a personal subscription. The dataset will include user identifiers, email addresses, geographical and TALG (Tell About Learning Goals) data, platform usage, problem-solving activity, purchase history, learning days, and email engagement metrics.

2. The logical parts of the query are:
- talg_data
- user_activity
- user_features
- rfm_quantiles
- users_rfm_scores
- rfm_segments_statistics
- recency_distribution
- frequency_distribution
- monetary_distribution

3. Part descriptions:
- talg_data: Extracts unique user responses to two specific questions from the 'polls' table, filtering by a particular poll_id and poll name.
- user_activity: Aggregates user actions from the 'content' table, calculating the last submission date, number of learning days, passed problems, read emails, and used platforms, excluding biased users and considering only specific actions.
- user_features: Combines user information from 'registered_users' with talg_data and user_activity, filtering out biased users and B2B users, and calculating various metrics such as days since last submission, days since last personal subscription start, and revenue.
- rfm_quantiles: Determines the quantiles for various metrics like days since last submission, passed problems, learning days, and revenue, based on users with personal subscriptions.
- users_rfm_scores: Joins the users' RFM features with the quantiles to calculate RFM scores for each user.
- rfm_segments_statistics: Calculates the distribution of users across different RFM scores.
- recency_distribution: Calculates the distribution of users across different recency scores.
- frequency_distribution: Calculates the distribution of users across different frequency scores.
- monetary_distribution: Calculates the distribution of users across different monetary scores.","Can we get a breakdown of our user engagement over the past year for those with personal subscriptions? Specifically, I'm interested in understanding their activity patterns, how often they're using the platform, and their spending behavior. It would be great to have this segmented by how recently they've engaged, how frequently, and how much they've spent."
